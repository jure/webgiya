<!-- surfelization.html
  CHANGELOG (high-level)
  - CHANGE #1 (Req.1): Simplified the scene: removed walls, added a cylinder pedestal, bunny sits on it.
  - CHANGE #2 (Req.2): Implemented the *real* despawn + keep-alive mechanism (kill-signal in touchedAtomic)
    and the same tile voting scheme (atomicMax for despawn, atomicMin for spawn).
  - CHANGE #3 (Req.3): Matched the reference surfelFindMissingPass.ts behavior:
      * same weight / scoringWeight definitions (weight uses overscale radius, scoreW uses base radius)
      * same "mahal" formula (d * (1 + abs(dot(offset, n))*squish))
      * same spawn probability formula (probMult * depth/64 * 1/(W*H))
      * same gateCoverage condition (second < 0.4, scoringWeight < 0.1, cnt < maxKeepAlive)
      * same despawn thresholds (mix(3.5,3.0,fullness) + mix(0.9,0.8,fullness))
      * same keep-alive rule (cell not overfull + dotN > 0.8 + not flagged for recycle)
    NOTE: We still intentionally do *brute-force neighbor search* (no offsets/list hash grid),
    but we add a tiny “cell count table” so the cnt-based logic matches the reference without
    introducing the full list grid yet.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGPU Surfelization Playground (Brute Force Coverage)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background:#0b0c10; }
    #app { width: 100%; height: 100%; }
    #hud {
      position: absolute;
      left: 10px; top: 10px;
      padding: 8px 10px;
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: #d7d7d7;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 8px;
      pointer-events: none;
      white-space: pre;
    }
    #fallback {
      position: absolute; inset: 0;
      display: none;
      place-items: center;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      padding: 24px;
    }
    a { color: #9bdcff; }
  </style>

  <!-- Import map so the code can keep your original-style specifiers -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.webgpu.js",
      "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.tsl.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="app"></div>
  <div id="hud">Initializing…</div>
  <div id="fallback"></div>

  <script type="module">
    import * as THREE from 'three/webgpu';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { Inspector } from 'three/addons/inspector/Inspector.js';
    import {
      // --- TSL core ---
      Fn, uniform, storage,
      int, uint, float, vec2, vec3, vec4,
      If, Loop,
      min, max, abs, dot, length, clamp, smoothstep, mix,
      texture, getViewPosition, uv,
      pass, output,

      // --- compute/threadgroup bits ---
      workgroupId, localId, workgroupBarrier, workgroupArray,
      atomicAdd, atomicMax, atomicMin, atomicStore, atomicLoad,

      // --- bit ops & packing ---
      bitAnd, bitOr, bitcast, floatBitsToUint,

      // --- MRT nodes ---
      mrt, normalWorldGeometry, diffuseColor,
      instancedArray, struct, instanceIndex, color
    } from 'three/tsl';

    // ============================================================
    // 0) CONFIG
    // ============================================================
    const MODEL_URL = '../models/bunny.glb'; // <--- put bunny.glb next to this html (or change path)

    // Constants aligned with src/constants.ts (real implementation)
    const SURFEL_LIFE_RECYCLE  = 0x8000000;
    const SURFEL_LIFE_RECYCLED = SURFEL_LIFE_RECYCLE + 1;

    // CHANGE #2: match reference semantics — despawn writes SURFEL_KILL_SIGNAL into touchedAtomic.
    // In the real code this is imported separately; here we pick the safe “huge” sentinel.
    const SURFEL_KILL_SIGNAL = SURFEL_LIFE_RECYCLE;

    const SURFEL_TTL_DEFAULT = 500;

    const SURFEL_BASE_RADIUS = 0.24;
    const SURFEL_RADIUS_OVERSCALE = 1.25;
    const SURFEL_NORMAL_DIRECTION_SQUISH = 2.0;

    // These match your grid constants; we use them to reproduce the *cnt* logic without building the full list grid yet.
    const SURFEL_GRID_CELL_DIAMETER = 0.2;
    const SURFEL_CS = 32;
    const SURFEL_RADIUS_REF_DIST = SURFEL_GRID_CELL_DIAMETER * SURFEL_CS * 0.5;

    // CHANGE #3: minimal “cell count” table size (single-cascade layout)
    const TOTAL_CELLS = SURFEL_CS * SURFEL_CS * SURFEL_CS;

    // Workgroup tile = 8x8 pixels
    const TILE_X = 8;
    const TILE_Y = 8;

    // CHANGE #3: world-size of one snapped grid “brick”
    const GRID_WORLD_SIZE = SURFEL_GRID_CELL_DIAMETER * SURFEL_CS;

    // ============================================================
    // 0.5) GRID ORIGIN SNAP (CPU) — matches snap_to_surfel_grid_origin in spirit
    // ============================================================
    // CHANGE #3: snap prev camera position to a stable grid origin (steps of GRID_WORLD_SIZE)
    function snapToSurfelGridOrigin(out, camPos) {
      out.set(
        Math.floor(camPos.x / GRID_WORLD_SIZE) * GRID_WORLD_SIZE,
        Math.floor(camPos.y / GRID_WORLD_SIZE) * GRID_WORLD_SIZE,
        Math.floor(camPos.z / GRID_WORLD_SIZE) * GRID_WORLD_SIZE
      );
      return out;
    }

    // ============================================================
    // 1) MATERIAL HELPERS
    // ============================================================
    function makeStandardMaterial(hex, roughness = 0.85, metalness = 0.0) {
      const mat = new THREE.MeshStandardNodeMaterial();
      mat.colorNode = color(hex);
      mat.color = new THREE.Color(hex);
      mat.roughnessNode = float(roughness);
      mat.metalnessNode = float(metalness);
      return mat;
    }

    // ============================================================
    // 2) GBUFFER (Normal + Diffuse + Depth)
    // ============================================================
    function createGBuffer(renderer, scale) {
      const dpr = renderer.getPixelRatio ? renderer.getPixelRatio() : window.devicePixelRatio;
      const w = Math.max(1, Math.floor(window.innerWidth  * dpr * scale));
      const h = Math.max(1, Math.floor(window.innerHeight * dpr * scale));

      const target = new THREE.RenderTarget(w, h, {
        count: 2,
        type: THREE.HalfFloatType,
        format: THREE.RGBAFormat,
        depthBuffer: true
      });

      target.depthTexture = new THREE.DepthTexture(w, h);
      target.textures[0].name = 'normal';
      target.textures[1].name = 'albedo';

      for (let i = 0; i < 2; i++) {
        target.textures[i].generateMipmaps = false;
        target.textures[i].magFilter = THREE.NearestFilter;
        target.textures[i].minFilter = THREE.NearestFilter;
      }

      // Encode normals to 0..1 for storage
      const sceneMRT = mrt({
        normal: normalWorldGeometry.mul(0.5).add(0.5),
        albedo: vec4(diffuseColor.rgb, 1.0)
      });
      sceneMRT.setName('gbufferMRT')

      function resize(newScale) {
        const dpr = renderer.getPixelRatio ? renderer.getPixelRatio() : window.devicePixelRatio;
        const w = Math.max(1, Math.floor(window.innerWidth  * dpr * newScale));
        const h = Math.max(1, Math.floor(window.innerHeight * dpr * newScale));
        target.setSize(w, h);
      }

      return { target, sceneMRT, resize };
    }

    // ============================================================
    // 3) HASH / RANDOM (copied + trimmed from your hashUtils.ts)
    // ============================================================
    const hash1 = Fn(([x_in]) => {
      let x = uint(x_in).toVar();
      x.addAssign(x.shiftLeft(10));
      x.bitXorAssign(x.shiftRight(6));
      x.addAssign(x.shiftLeft(3));
      x.bitXorAssign(x.shiftRight(11));
      x.addAssign(x.shiftLeft(15));
      return x;
    });

    const hashCombine2 = Fn(([x, y]) => {
      const M = uint(1664525);
      const C = uint(1013904223);
      let seed = x.mul(M).add(y).add(C).mul(M).toVar();
      seed.bitXorAssign(seed.shiftRight(11));
      seed.bitXorAssign(seed.shiftLeft(7).bitAnd(uint(0x9d2c5680)));
      seed.bitXorAssign(seed.shiftLeft(15).bitAnd(uint(0xefc60000)));
      seed.bitXorAssign(seed.shiftRight(18));
      return seed;
    });

    const uintToU01Float = Fn(([h_in]) => {
      let h = uint(h_in).toVar();
      const mantissaMask = uint(0x007FFFFF);
      const one = uint(0x3F800000);
      h.bitAndAssign(mantissaMask);
      h.bitOrAssign(one);
      const r = bitcast(h, 'float');
      return r.sub(1.0);
    });

    // ============================================================
    // 3.5) GRID HASH (TSL) — used by the count table and brute-force neighbor filtering
    // ============================================================
    // CHANGE #3: Emulate surfel_pos_to_grid_coord + surfel_grid_coord_to_hash (single-cascade)
    const posToCellHash = Fn(([pos, origin]) => {
      const pRel = vec3(pos).sub(vec3(origin));

      const invCell = float(1.0 / SURFEL_GRID_CELL_DIAMETER);
      const half = int(SURFEL_CS / 2);
      const cs1 = int(SURFEL_CS - 1);
      const cs = int(SURFEL_CS);
      const cs2 = int(SURFEL_CS * SURFEL_CS);

      // floor(pRel / cellDiameter) + CS/2, then clamp into [0..CS-1]
      let gx = pRel.x.mul(invCell).floor().toInt().add(half).toVar();
      let gy = pRel.y.mul(invCell).floor().toInt().add(half).toVar();
      let gz = pRel.z.mul(invCell).floor().toInt().add(half).toVar();

      gx.assign(min(max(gx, int(0)), cs1));
      gy.assign(min(max(gy, int(0)), cs1));
      gz.assign(min(max(gz, int(0)), cs1));

      // linear index
      return gx.add(gy.mul(cs)).add(gz.mul(cs2));
    });

    // ============================================================
    // 4) SURFEL POOL (pos+normal+age + free-stack + atomics)
    // ============================================================
    const SurfelPacked = struct({
      posr: 'vec4',
      normal: 'vec3',
      age: 'int'
    }, 'SurfelPacked');

    function createSurfelPool() {
      let capacity = 0;

      let surfelAttr = null;      // StorageBufferAttribute (itemSize 8)
      let poolAttr = null;        // StorageInstancedBufferAttribute (int stack)
      let touchedAtomic = null;   // StorageBufferNode (atomic int per surfel): keepalive credit OR kill signal
      let poolAllocAtomic = null; // StorageBufferNode (atomic int)
      let poolMaxAtomic = null;   // StorageBufferNode (atomic int)

      // Debug readback: counters only
      let statsAttr = null;
      let statsStore = null;
      let statsNode = null;

      function ensureCapacity(nextCap) {
        if (capacity === nextCap && surfelAttr) return;
        capacity = nextCap;

        // Surfel buffer: 8 floats per surfel
        surfelAttr = new THREE.StorageBufferAttribute(new Float32Array(capacity * 8), 8);

        // Free stack (pool[i] = i)
        const poolIdx = new Int32Array(capacity);
        for (let i = 0; i < capacity; i++) poolIdx[i] = i;
        poolAttr = new THREE.StorageInstancedBufferAttribute(poolIdx, 1);
        poolAttr.needsUpdate = true;

        // Atomics
        poolAllocAtomic = instancedArray(new Int32Array(1), 'int').toAtomic().setName('poolAlloc');
        poolMaxAtomic   = instancedArray(new Int32Array(1), 'int').toAtomic().setName('poolMax');
        touchedAtomic   = instancedArray(new Int32Array(capacity), 'int').toAtomic().setName('surfelTouched');

        // Reset stats readback when buffers are recreated
        statsAttr = null;
        statsStore = null;
        statsNode = null;
      }

      function getCapacity() { return capacity; }
      function getSurfelAttr() { return surfelAttr; }
      function getPoolAttr() { return poolAttr; }
      function getTouchedAtomic() { return touchedAtomic; }
      function getPoolAllocAtomic() { return poolAllocAtomic; }
      function getPoolMaxAtomic() { return poolMaxAtomic; }

      async function readStatsAsync(renderer) {
        if (!poolAllocAtomic || !poolMaxAtomic) return null;
        if (!statsAttr) {
          statsAttr = new THREE.StorageInstancedBufferAttribute(new Int32Array(2), 1);
          statsStore = storage(statsAttr, 'int', 2);
          statsNode = null;
        }

        if (!statsNode) {
          statsNode = Fn(() => {
            statsStore.element(0).assign(atomicAdd(poolAllocAtomic.element(0), int(0)));
            statsStore.element(1).assign(atomicAdd(poolMaxAtomic.element(0), int(0)));
          })().compute(1).setName('Surfel Pool Stats');
        }

        await renderer.compute(statsNode);
        const ab = await renderer.getArrayBufferAsync(statsAttr);
        return new Int32Array(ab);
      }

      return {
        ensureCapacity,
        getCapacity,
        getSurfelAttr,
        getPoolAttr,
        getTouchedAtomic,
        getPoolAllocAtomic,
        getPoolMaxAtomic,
        readStatsAsync
      };
    }

    // ============================================================
    // 5) RESET / INIT POOL
    // ============================================================
    function createSurfelResetPass() {
      let initNode = null;
      let metaNode = null;

      function run(renderer, pool) {
        const cap = pool.getCapacity();
        const surfelAttr = pool.getSurfelAttr();
        const poolAttr = pool.getPoolAttr();
        const poolAlloc = pool.getPoolAllocAtomic();
        const poolMax = pool.getPoolMaxAtomic();
        const touched = pool.getTouchedAtomic();

        if (!surfelAttr || !poolAttr || !poolAlloc || !poolMax || !touched) return;

        const surfels = storage(surfelAttr, SurfelPacked, cap);
        const poolBuf = storage(poolAttr, 'int', cap);

        if (!initNode) {
          initNode = Fn(() => {
            const i = int(instanceIndex);

            // clear surfel
            surfels.element(i).get('posr').assign(vec4(0, 0, 0, 0));
            surfels.element(i).get('normal').assign(vec3(0, 1, 0));
            surfels.element(i).get('age').assign(int(SURFEL_LIFE_RECYCLED));

            // refill free stack
            poolBuf.element(i).assign(i);

            // clear touched
            atomicStore(touched.element(i), int(0));
          })().compute(cap).setName('Surfel Reset Init');
        }

        if (!metaNode) {
          metaNode = Fn(() => {
            atomicStore(poolAlloc.element(0), int(0));
            atomicStore(poolMax.element(0), int(0));
          })().compute(1).setName('Surfel Reset Meta');
        }

        renderer.compute(initNode);
        renderer.compute(metaNode);
      }

      return { run };
    }

    // ============================================================
    // 6) AGE / RECYCLE PASS
    // ============================================================
    function createSurfelAgePass() {
      let node = null;

      // Uniforms (interactive)
      const U_TTL = uniform(SURFEL_TTL_DEFAULT);
      const U_AGE_STEP = uniform(1);
      const U_FORCE_KILL = uniform(false);

      function setParams({ ttl, ageStep, forceKill }) {
        if (ttl != null) U_TTL.value = ttl;
        if (ageStep != null) U_AGE_STEP.value = ageStep;
        if (forceKill != null) U_FORCE_KILL.value = forceKill;
      }

      function run(renderer, pool) {
        const cap = pool.getCapacity();
        const surfelAttr = pool.getSurfelAttr();
        const poolAttr = pool.getPoolAttr();
        const poolAlloc = pool.getPoolAllocAtomic();
        const poolMax = pool.getPoolMaxAtomic();
        const touched = pool.getTouchedAtomic();

        if (!surfelAttr || !poolAttr || !poolAlloc || !poolMax || !touched) return;

        if (!node || node.__cap !== cap) {
          const surfels = storage(surfelAttr, SurfelPacked, cap);
          const poolBuf = storage(poolAttr, 'int', cap);

          // CHANGE #2/#3: Match reference touched semantics:
          // - touchedAtomic stores either keepalive credit (e.g. 5) OR a kill signal (SURFEL_KILL_SIGNAL)
          // - age pass reads + clears touched each frame
          // - if kill signal present => recycle immediately
          node = Fn(() => {
            const idx = int(instanceIndex);
            const total = atomicAdd(poolMax.element(0), int(0));
            const inRange = idx.lessThan(total);

            If(inRange, () => {
              const s = surfels.element(idx);
              const ageNode = s.get('age');
              let ageNow = int(ageNode).toVar();

              const isRecycled = ageNow.equal(int(SURFEL_LIFE_RECYCLED));
              If(isRecycled.not(), () => {
                // Read + clear touched
                const touch = atomicAdd(touched.element(idx), int(0)).toVar();
                atomicStore(touched.element(idx), int(0));

                // Kill request from despawn
                const killReq = touch.greaterThanEqual(int(SURFEL_KILL_SIGNAL));

                // Force-kill debug
                If(U_FORCE_KILL, () => {
                  ageNow.assign(int(SURFEL_LIFE_RECYCLE));
                  ageNode.assign(int(SURFEL_LIFE_RECYCLE));
                });

                // If kill requested, mark for recycle
                If(killReq, () => {
                  ageNow.assign(int(SURFEL_LIFE_RECYCLE));
                  ageNode.assign(int(SURFEL_LIFE_RECYCLE));
                });

                // Recycle path
                const shouldRecycle = ageNow.equal(int(SURFEL_LIFE_RECYCLE)).or(ageNow.greaterThanEqual(int(U_TTL)));
                If(shouldRecycle, () => {
                  ageNode.assign(int(SURFEL_LIFE_RECYCLED));

                  // push back into free stack
                  const oldAlloc = atomicAdd(poolAlloc.element(0), int(-1));
                  const slot = oldAlloc.sub(int(1));
                  If(slot.greaterThanEqual(int(0)).and(slot.lessThan(int(cap))), () => {
                    poolBuf.element(slot).assign(idx);
                  });
                }).Else(() => {
                  const step = int(U_AGE_STEP);
                  // age += max(step - touchCredit, 0)
                  const delta = max(int(0), step.sub(touch));
                  const nextAge = max(int(0), ageNow.add(delta));
                  ageNow.assign(nextAge);
                  ageNode.assign(nextAge);

                  If(ageNow.greaterThanEqual(int(U_TTL)), () => {
                    ageNode.assign(int(SURFEL_LIFE_RECYCLED));

                    const oldAlloc = atomicAdd(poolAlloc.element(0), int(-1));
                    const slot = oldAlloc.sub(int(1));
                    If(slot.greaterThanEqual(int(0)).and(slot.lessThan(int(cap))), () => {
                      poolBuf.element(slot).assign(idx);
                    });
                  });
                });
              });
            });
          })().compute(cap).setName('Surfel Age/Recycling (KillSignal)');

          node.__cap = cap;
        }

        renderer.compute(node);
      }

      return { run, setParams, U_TTL };
    }

    // ============================================================
    // 6.5) CELL COUNT TABLE (tiny “grid behavior parity” without the full list grid)
    // ============================================================
    // CHANGE #3: This pass builds counts[hash] = #alive surfels in that cell.
    // It enables cnt-based keepalive/despawn/spawn gating to match the reference implementation.
    function createSurfelCellCountPass() {
      const cellCounts = instancedArray(new Int32Array(TOTAL_CELLS), 'int').toAtomic().setName('cellCounts');

      const U_GRID_ORIGIN = uniform(new THREE.Vector3());
      const U_TTL = uniform(SURFEL_TTL_DEFAULT);

      let resetNode = null;
      let buildNode = null;
      let lastCap = -1;

      function setParams({ ttl }) {
        if (ttl != null) U_TTL.value = ttl;
      }

      function run(renderer, pool, prevGridOrigin) {
        const cap = pool.getCapacity();
        const surfelAttr = pool.getSurfelAttr();
        const poolMax = pool.getPoolMaxAtomic();
        if (!surfelAttr || !poolMax) return;

        U_GRID_ORIGIN.value.copy(prevGridOrigin);

        // Reset counts each frame
        if (!resetNode) {
          resetNode = Fn(() => {
            const i = int(instanceIndex);
            atomicStore(cellCounts.element(i), int(0));
          })().compute(TOTAL_CELLS).setName('CellCount Reset');
        }

        // Rebuild buildNode if capacity changes
        if (!buildNode || lastCap !== cap) {
          lastCap = cap;
          const surfels = storage(surfelAttr, SurfelPacked, cap);

          buildNode = Fn(() => {
            const idx = int(instanceIndex);
            const total = atomicAdd(poolMax.element(0), int(0));
            const inRange = idx.lessThan(total);

            If(inRange, () => {
              const s = surfels.element(idx);
              const age = int(s.get('age')).toVar();
              const alive = age.lessThan(int(U_TTL));

              If(alive, () => {
                const sPos = s.get('posr').xyz;
                const h = posToCellHash(sPos, U_GRID_ORIGIN).toVar();
                // ++cellCounts[h]
                atomicAdd(cellCounts.element(h), int(1));
              });
            });
          })().compute(cap).setName('CellCount Build');
        }

        renderer.compute(resetNode);
        renderer.compute(buildNode);
      }

      return {
        run,
        setParams,
        getCellCountsAtomic: () => cellCounts,
        U_GRID_ORIGIN
      };
    }

    // ============================================================
    // 7) FIND MISSING (BRUTE FORCE COVERAGE, NO GRID LIST)
    // ============================================================
    function createSurfelFindMissingBruteForcePass(cellCountsAtomic) {
      const U_FRAME = uniform(0);
      const U_PROJ_INV = uniform(new THREE.Matrix4());
      const U_CAM_WORLD = uniform(new THREE.Matrix4());
      const U_CAM_POS = uniform(new THREE.Vector3());

      // Reference has these; we keep them for parity
      const U_PREV_CAM_POS = uniform(new THREE.Vector3());      // mostly informational here
      const U_PREV_GRID_ORIGIN = uniform(new THREE.Vector3());  // snapped origin used for cell hashing

      const U_SCREEN_SIZE = uniform(new THREE.Vector2());
      const U_GRID_STRIDE = uniform(1); // tile grid width

      // Tuning (should match reference defaults)
      const U_TTL = uniform(SURFEL_TTL_DEFAULT);

      // CHANGE #3: In a real grid, we only traverse the cell list.
      // Here we still brute-force scan surfels, but we cap the scan for safety.
      const U_MAX_SCAN = uniform(2048);

      const U_BASE_RADIUS = uniform(SURFEL_BASE_RADIUS);
      const U_RADIUS_REF_DIST = uniform(SURFEL_RADIUS_REF_DIST);
      const U_RADIUS_OVERSCALE = uniform(SURFEL_RADIUS_OVERSCALE);
      const U_NORMAL_SQUISH = uniform(SURFEL_NORMAL_DIRECTION_SQUISH);

      // Reference constants exposed for parity
      const U_MAX_SURFELS_PER_CELL = uniform(64);     // MAX_SURFELS_PER_CELL
      const U_MAX_KEEP_ALIVE = uniform(32);           // MAX_SURFELS_PER_CELL_FOR_KEEP_ALIVE
      const U_KEEPALIVE_CREDIT = uniform(5);          // atomicMax(touched, 5)

      const U_COVERAGE_THRESHOLD = uniform(0.1);      // scoringWeight < 0.1
      const U_SECOND_GATE = uniform(0.4);             // second < 0.4

      // Spawn probability parameters (reference)
      const U_PROB_MULT = uniform(5000.0);            // probMult
      const U_DEPTH_DIV = uniform(64.0);              // pt_depth / 64

      const U_DESPAWN_ENABLED = uniform(true);

      // Outputs
      const tileAllocAttr = new THREE.StorageBufferAttribute(new Int32Array(2), 1);
      const candPosAttr = new THREE.StorageBufferAttribute(new Float32Array(4), 4);
      const candNorAttr = new THREE.StorageBufferAttribute(new Float32Array(4), 4);

      let computeNode = null;
      let lastTileCount = -1;
      let lastSurfelAttr = null;
      let lastDepthTex = null;
      let lastNormalTex = null;

      function ensureTileBuffers(tileCount) {
        const needed = Math.max(1, tileCount);

        // 2 ints per tile
        if (tileAllocAttr.count < needed * 2) {
          tileAllocAttr.array = new Int32Array(needed * 2);
          tileAllocAttr.count = needed * 2;
          tileAllocAttr.needsUpdate = true;
        }
        if (candPosAttr.count < needed) {
          candPosAttr.array = new Float32Array(needed * 4);
          candPosAttr.count = needed;
          candPosAttr.needsUpdate = true;
        }
        if (candNorAttr.count < needed) {
          candNorAttr.array = new Float32Array(needed * 4);
          candNorAttr.count = needed;
          candNorAttr.needsUpdate = true;
        }
      }

      function setParams(p) {
        if (p.ttl != null) U_TTL.value = p.ttl;
        if (p.maxScan != null) U_MAX_SCAN.value = p.maxScan;

        if (p.baseRadius != null) U_BASE_RADIUS.value = p.baseRadius;
        if (p.radiusRefDist != null) U_RADIUS_REF_DIST.value = p.radiusRefDist;
        if (p.radiusOverscale != null) U_RADIUS_OVERSCALE.value = p.radiusOverscale;
        if (p.normalSquish != null) U_NORMAL_SQUISH.value = p.normalSquish;

        if (p.maxSurfelsPerCell != null) U_MAX_SURFELS_PER_CELL.value = p.maxSurfelsPerCell;
        if (p.maxKeepAlive != null) U_MAX_KEEP_ALIVE.value = p.maxKeepAlive;
        if (p.keepAliveCredit != null) U_KEEPALIVE_CREDIT.value = p.keepAliveCredit;

        if (p.coverageThreshold != null) U_COVERAGE_THRESHOLD.value = p.coverageThreshold;
        if (p.secondGate != null) U_SECOND_GATE.value = p.secondGate;

        if (p.probMult != null) U_PROB_MULT.value = p.probMult;
        if (p.depthDiv != null) U_DEPTH_DIV.value = p.depthDiv;

        if (p.despawnEnabled != null) U_DESPAWN_ENABLED.value = p.despawnEnabled;
      }

      function run(renderer, camera, gbuffer, pool, prevCameraPos, prevGridOrigin) {
        const surfelAttr = pool.getSurfelAttr();
        const poolMax = pool.getPoolMaxAtomic();
        const touched = pool.getTouchedAtomic();

        const texDepth = gbuffer.target.depthTexture;
        const texNormal = gbuffer.target.textures[0];

        if (!surfelAttr || !poolMax || !touched || !texDepth || !texNormal) return { tileCount: 0 };

        const w = gbuffer.target.width;
        const h = gbuffer.target.height;

        const tileW = Math.max(1, Math.ceil(w / TILE_X));
        const tileH = Math.max(1, Math.ceil(h / TILE_Y));
        const tileCount = tileW * tileH;

        ensureTileBuffers(tileCount);

        // Uniforms
        U_FRAME.value = renderer.info.frame;
        U_PROJ_INV.value.copy(camera.projectionMatrixInverse);
        U_CAM_WORLD.value.copy(camera.matrixWorld);
        U_CAM_POS.value.copy(camera.position);

        U_PREV_CAM_POS.value.copy(prevCameraPos);
        U_PREV_GRID_ORIGIN.value.copy(prevGridOrigin);

        U_SCREEN_SIZE.value.set(w, h);
        U_GRID_STRIDE.value = tileW;

        const mustRebuild =
          (tileCount !== lastTileCount) ||
          (surfelAttr !== lastSurfelAttr) ||
          (texDepth !== lastDepthTex) ||
          (texNormal !== lastNormalTex);

        if (mustRebuild) {
          computeNode = null;
          lastTileCount = tileCount;
          lastSurfelAttr = surfelAttr;
          lastDepthTex = texDepth;
          lastNormalTex = texNormal;
        }

        if (!computeNode) {
          const cap = surfelAttr.count;
          const surfels = storage(surfelAttr, SurfelPacked, cap);

          const tileAlloc = storage(tileAllocAttr, 'int', tileAllocAttr.count);
          const candPos = storage(candPosAttr, 'vec4', candPosAttr.count);
          const candNor = storage(candNorAttr, 'vec4', candNorAttr.count);

          const computeLogic = Fn(() => {
            const gx = workgroupId.x.toInt();
            const gy = workgroupId.y.toInt();
            const lx = localId.x.toInt();
            const ly = localId.y.toInt();

            const laneIndex = ly.mul(int(TILE_X)).add(lx);
            const tileIndex = gy.mul(int(U_GRID_STRIDE)).add(gx);

            // groupshared:
            // - min packed totalWeight for spawn
            // - max packed scoringWeight for despawn
            const gs_px_min_score_loc_packed = workgroupArray('atomic<u32>', 1);
            const gs_px_max_score_loc_packed = workgroupArray('atomic<u32>', 1);

            // Per-lane state (needs to survive into spawn/despawn execute sections)
            const worldPos = vec3(0).toVar();
            const normalW  = vec3(0,1,0).toVar();
            const flatHash = int(0).toVar();
            const validPixel = int(0).toVar(); // 1 if valid depth, else 0

            const bestParentSid = int(-1).toVar();
            const maxParentWeight = float(-1.0).toVar();

            // init
            If(laneIndex.equal(int(0)), () => {
              const base = tileIndex.mul(int(2));
              tileAlloc.element(base).assign(int(0));
              tileAlloc.element(base.add(int(1))).assign(int(0));
              candPos.element(tileIndex).assign(vec4(0,0,0,0));
              candNor.element(tileIndex).assign(vec4(0,0,1,0));

              atomicStore(gs_px_min_score_loc_packed.element(int(0)), uint(0xFFFFFFFF));
              atomicStore(gs_px_max_score_loc_packed.element(int(0)), uint(0));
            });

            workgroupBarrier();

            const widthF  = U_SCREEN_SIZE.x;
            const heightF = U_SCREEN_SIZE.y;
            const widthI  = int(widthF);
            const heightI = int(heightF);

            const px = gx.mul(int(TILE_X)).add(lx);
            const py = gy.mul(int(TILE_Y)).add(ly);
            const pixelInBounds = px.lessThan(widthI).and(py.lessThan(heightI));

            If(pixelInBounds, () => {
              const uv = vec2(
                px.toFloat().add(0.5).div(widthF),
                py.toFloat().add(0.5).div(heightF)
              );

              const depth = texture(texDepth, uv).r;
              const valid = depth.greaterThan(1e-6).and(depth.lessThan(0.999));

              If(valid, () => {
                validPixel.assign(int(1));

                const viewPosRaw = getViewPosition(uv, depth, U_PROJ_INV);
                const worldPos4 = U_CAM_WORLD.mul(vec4(viewPosRaw, 1.0));
                worldPos.assign(worldPos4.xyz);

                const encN = texture(texNormal, uv).xyz;
                normalW.assign(encN.mul(2.0).sub(1.0).normalize());

                const pt_depth = viewPosRaw.z.negate(); // >0

                // --- cell hash (reference uses prev grid origin) ---
                const hsh = posToCellHash(worldPos, U_PREV_GRID_ORIGIN).toVar();
                flatHash.assign(hsh);

                // cnt from cellCount table
                const cnt = atomicAdd(cellCountsAtomic.element(hsh), int(0)).toVar();
                const maxKeepAlive = int(U_MAX_KEEP_ALIVE);
                const maxCell = int(U_MAX_SURFELS_PER_CELL);

                // loopCount = min(cnt, MAX_SURFELS_PER_CELL*2)
                const loopCountWanted = min(cnt, maxCell.mul(int(2))).toVar();

                // brute-force scan cap (safety)
                const total = atomicAdd(poolMax.element(0), int(0)).toVar();
                const scanCount = min(min(total, int(cap)), int(U_MAX_SCAN)).toVar();

                const totalWeight = float(0).toVar();
                const scoringWeight = float(0).toVar();
                const highest = float(0).toVar();
                const second = float(0).toVar();

                // How many matching-cell surfels we've processed so far.
                const processed = int(0).toVar();

                // precompute boolean: only keepalive if cell is not overfull
                const canKeepAlive = cnt.lessThanEqual(maxKeepAlive);

                // --- Random seed (same as reference) ---
                const seed = hashCombine2(
                  hashCombine2(uint(px), hash1(uint(py))),
                  uint(U_FRAME)
                ).toVar();

                Loop(scanCount, ({ i }) => {
                  // Stop doing heavy work once we've processed loopCountWanted matches.
                  const stillNeed = processed.lessThan(loopCountWanted);

                  // If we already have enough matches, skip everything.
                  If(stillNeed, () => {
                    const sid = int(i);
                    const s = surfels.element(sid);

                    const age = int(s.get('age')).toVar();
                    const alive = age.lessThan(int(U_TTL)); // grid contains only alive surfels in ref; emulate that.

                    If(alive, () => {
                      const posr = s.get('posr');
                      const sPos = posr.xyz;
                      const sNor = s.get('normal');

                      // strict hash check (isSameHash)
                      const sh = posToCellHash(sPos, U_PREV_GRID_ORIGIN);
                      const isSameHash = sh.equal(hsh);

                      If(isSameHash, () => {
                        processed.addAssign(int(1));

                        // surfel_radius_for_pos(posr.xyz, U_CAM_POS)
                        const distCam = length(sPos.sub(U_CAM_POS));
                        const surfelRadius = float(U_BASE_RADIUS).mul(
                          max(float(1.0), distCam.div(float(U_RADIUS_REF_DIST)))
                        );

                        const posOffset = worldPos.sub(sPos);
                        const d = length(posOffset);

                        // CHANGE #3: match reference mahal = d * (1 + abs(dot(offset,n))*squish)
                        const alignPenalty = abs(dot(posOffset, sNor)).mul(float(U_NORMAL_SQUISH));
                        const mahal = d.mul(float(1.0).add(alignPenalty));

                        const dotN = max(float(0.0), dot(sNor, normalW));

                        const weight = smoothstep(
                          surfelRadius.mul(float(U_RADIUS_OVERSCALE)),
                          float(0.0),
                          mahal
                        ).mul(dotN);

                        const scoreW = smoothstep(
                          surfelRadius,
                          float(0.0),
                          mahal
                        ).mul(dotN);

                        totalWeight.addAssign(weight);
                        scoringWeight.addAssign(scoreW);

                        // isMature = (frame - birthFrame) >= 8 && dotN > 0.9
                        const isMature = float(U_FRAME).sub(posr.w).greaterThanEqual(float(8.0)).and(dotN.greaterThan(float(0.9)));
                        If(isMature.and(weight.greaterThan(maxParentWeight)), () => {
                          bestParentSid.assign(sid);
                          maxParentWeight.assign(weight);
                        });

                        If(weight.greaterThan(highest), () => {
                          second.assign(highest);
                          highest.assign(weight);
                        }).ElseIf(weight.greaterThan(second), () => {
                          second.assign(weight);
                        });

                        // Keep-alive (reference)
                        const isRecycle = age.equal(int(SURFEL_LIFE_RECYCLE));
                        const sameCellKeep = canKeepAlive.and(dotN.greaterThan(float(0.8))).and(isRecycle.not());
                        If(sameCellKeep, () => {
                          atomicMax(touched.element(sid), int(U_KEEPALIVE_CREDIT));
                        });
                      });
                    });
                  });
                });

                // -------------------------
                // Despawn logic (reference)
                // -------------------------
                const fullness = smoothstep(
                  float(maxKeepAlive).mul(float(0.75)),
                  float(maxKeepAlive).mul(float(1.0)),
                  float(cnt)
                );
                const despawnThreshold = mix(float(3.5), float(3.0), fullness);
                const secondThresh = mix(float(0.9), float(0.8), fullness);

                const shouldConsiderDespawn =
                  U_DESPAWN_ENABLED
                    .and(scoringWeight.greaterThan(despawnThreshold))
                    .and(second.greaterThan(secondThresh));

                If(shouldConsiderDespawn, () => {
                  const scoreBits = floatBitsToUint(scoringWeight);
                  const packedVote = bitOr(
                    bitAnd(scoreBits, uint(0xFFFFFFC0)),
                    uint(laneIndex)
                  );
                  atomicMax(gs_px_max_score_loc_packed.element(int(0)), packedVote);
                });

                // -----------------------
                // Spawn logic (reference)
                // -----------------------
                const depthWeight = pt_depth.div(float(U_DEPTH_DIV));
                const invW = float(1.0).div(widthF);
                const invH = float(1.0).div(heightF);
                const prob = float(U_PROB_MULT).mul(depthWeight).mul(invW).mul(invH);

                // hash1_mut(seed)
                seed.assign(hash1(seed));
                const randomOk = uintToU01Float(seed).lessThan(prob);

                const gateCoverage =
                  second.lessThan(float(U_SECOND_GATE))
                    .and(scoringWeight.lessThan(float(U_COVERAGE_THRESHOLD)))
                    .and(cnt.lessThan(maxKeepAlive));

                const wantSpawn = gateCoverage.and(randomOk);

                If(wantSpawn, () => {
                  const scoreAsUint = floatBitsToUint(totalWeight);
                  const packedVal = bitOr(
                    bitAnd(scoreAsUint, uint(0xFFFFFFC0)),
                    uint(laneIndex)
                  );
                  atomicMin(gs_px_min_score_loc_packed.element(int(0)), packedVal);
                });
              });
            });

            workgroupBarrier();

            // --- Execute Despawn (winner takes action) ---
            const maxScorePacked = atomicLoad(gs_px_max_score_loc_packed.element(int(0)));
            If(maxScorePacked.notEqual(uint(0)).and(validPixel.equal(int(1))), () => {
              const winningLane = bitAnd(maxScorePacked, uint(63)).toInt();

              If(laneIndex.equal(winningLane), () => {
                const victimIdx = int(-1).toVar();
                const maxVictimWeight = float(-1.0).toVar();

                // Recompute loopCountWanted + scanCount for this pixel
                const cnt = atomicAdd(cellCountsAtomic.element(flatHash), int(0)).toVar();
                const maxCell = int(U_MAX_SURFELS_PER_CELL);
                const loopCountWanted = min(cnt, maxCell.mul(int(2))).toVar();

                const total = atomicAdd(poolMax.element(0), int(0)).toVar();
                const scanCount = min(min(total, int(cap)), int(U_MAX_SCAN)).toVar();

                const processed = int(0).toVar();

                Loop(scanCount, ({ i }) => {
                  const stillNeed = processed.lessThan(loopCountWanted);
                  If(stillNeed, () => {
                    const sid = int(i);
                    const s = surfels.element(sid);
                    const age = int(s.get('age')).toVar();
                    const alive = age.lessThan(int(U_TTL));

                    If(alive, () => {
                      const sPos = s.get('posr').xyz;
                      const sNor = s.get('normal');

                      const sh = posToCellHash(sPos, U_PREV_GRID_ORIGIN);
                      const isSameHash = sh.equal(flatHash);

                      If(isSameHash, () => {
                        processed.addAssign(int(1));

                        const distCam = length(sPos.sub(U_CAM_POS));
                        const surfelRadius = float(U_BASE_RADIUS).mul(
                          max(float(1.0), distCam.div(float(U_RADIUS_REF_DIST)))
                        );

                        const posOffset = worldPos.sub(sPos);
                        const d = length(posOffset);
                        const alignPenalty = abs(dot(posOffset, sNor)).mul(float(U_NORMAL_SQUISH));
                        const mahal = d.mul(float(1.0).add(alignPenalty));

                        const dirW = max(float(0.0), dot(sNor, normalW));
                        const w = smoothstep(
                          surfelRadius.mul(float(U_RADIUS_OVERSCALE)),
                          float(0.0),
                          mahal
                        ).mul(dirW);

                        If(w.greaterThanEqual(maxVictimWeight), () => {
                          maxVictimWeight.assign(w);
                          victimIdx.assign(sid);
                        });
                      });
                    });
                  });
                });

                If(victimIdx.notEqual(int(-1)), () => {
                  atomicMax(touched.element(victimIdx), int(SURFEL_KILL_SIGNAL));
                });
              });
            });

            // --- Execute Spawn (winner takes action) ---
            const bestPacked = atomicLoad(gs_px_min_score_loc_packed.element(int(0)));
            If(bestPacked.notEqual(uint(0xFFFFFFFF)).and(validPixel.equal(int(1))), () => {
              const winningLaneIndex = bitAnd(bestPacked, uint(63)).toInt();

              If(laneIndex.equal(winningLaneIndex), () => {
                const base = tileIndex.mul(int(2));
                tileAlloc.element(base).assign(int(1));
                // Store parent sid (reference)
                tileAlloc.element(base.add(int(1))).assign(bestParentSid);

                candPos.element(tileIndex).assign(vec4(worldPos, 1.0));
                candNor.element(tileIndex).assign(vec4(normalW, 1.0));
              });
            });
          });

          computeNode = computeLogic()
            .computeKernel([TILE_X, TILE_Y, 1])
            .setName('Find Missing (Brute Force, Ref Parity)');
        }

        renderer.compute(computeNode, [tileW, tileH, 1]);
        return { tileCount };
      }

      return {
        run,
        setParams,
        getTileAllocAttr: () => tileAllocAttr,
        getCandPosAttr: () => candPosAttr,
        getCandNorAttr: () => candNorAttr
      };
    }

    // ============================================================
    // 8) ALLOCATE PASS
    // ============================================================
    function createSurfelAllocatePass() {
      const U_FRAME = uniform(0);
      let node = null;
      let lastTileCount = -1;
      let lastCap = -1;

      function run(renderer, pool, find, tileCount) {
        if (tileCount <= 0) return;

        const cap = pool.getCapacity();
        const surfelAttr = pool.getSurfelAttr();
        const poolAttr = pool.getPoolAttr();
        const poolAlloc = pool.getPoolAllocAtomic();
        const poolMax = pool.getPoolMaxAtomic();

        const tileAllocAttr = find.getTileAllocAttr();
        const candPosAttr = find.getCandPosAttr();
        const candNorAttr = find.getCandNorAttr();

        if (!surfelAttr || !poolAttr || !poolAlloc || !poolMax || !tileAllocAttr || !candPosAttr || !candNorAttr) return;

        U_FRAME.value = renderer.info.frame;

        if (!node || lastTileCount !== tileCount || lastCap !== cap) {
          lastTileCount = tileCount;
          lastCap = cap;

          const surfels = storage(surfelAttr, SurfelPacked, cap);
          const poolBuf = storage(poolAttr, 'int', cap);

          const tileAlloc = storage(tileAllocAttr, 'int', tileAllocAttr.count);
          const candPos = storage(candPosAttr, 'vec4', candPosAttr.count);
          const candNor = storage(candNorAttr, 'vec4', candNorAttr.count);

          node = Fn(() => {
            const tile = int(instanceIndex);
            const base = tile.mul(int(2));
            const spawnFlag = tileAlloc.element(base);

            If(spawnFlag.equal(int(1)), () => {
              // pop from free-stack
              const prevAlloc = atomicAdd(poolAlloc.element(0), int(1));
              const within = prevAlloc.lessThan(int(cap));

              If(within, () => {
                const surfelIdx = poolBuf.element(prevAlloc);

                atomicMax(poolMax.element(0), surfelIdx.add(int(1)));

                const p = candPos.element(tile);
                const n = candNor.element(tile).xyz.normalize();

                const s = surfels.element(surfelIdx);
                s.get('posr').assign(vec4(p.xyz, float(U_FRAME))); // birth frame in w (matches reference usage)
                s.get('normal').assign(n);
                s.get('age').assign(int(0));
              }).Else(() => {
                atomicAdd(poolAlloc.element(0), int(-1));
              });
            });
          })().compute(tileCount).setName('Surfel Allocate');
        }

        renderer.compute(node);
      }

      return { run };
    }

    // ============================================================
    // 9) SCENE (simplified)
    // ============================================================
    async function buildScene(scene) {
      // Lights
      const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.45);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 2.2);
      dir.position.set(3, 6, 2);
      scene.add(dir);

      const pedestalH = 0.85;
      const pedestalR = 1.1;
      const pedestal = new THREE.Mesh(
        new THREE.CylinderGeometry(pedestalR, pedestalR, pedestalH, 48, 1, false),
        makeStandardMaterial(0x6f737a, 0.9, 0.0)
      );
      pedestal.position.set(0, pedestalH * 0.5, 0);
      scene.add(pedestal);

      // Bunny
      const loader = new GLTFLoader();
      let bunnyRoot = null;

      try {
        const gltf = await loader.loadAsync(MODEL_URL);
        bunnyRoot = gltf.scene;
      } catch (e) {
        console.warn('Failed to load bunny.glb. Falling back to a sphere.', e);
        const fallback = new THREE.Mesh(
          new THREE.SphereGeometry(0.65, 40, 28),
          makeStandardMaterial(0xe8e3d4, 0.6, 0.0)
        );
        fallback.position.set(0, pedestalH + 0.65, 0);
        scene.add(fallback);
        return { bunny: fallback, pedestal };
      }

      bunnyRoot.traverse((o) => {
        if (o && o.isMesh) o.material = makeStandardMaterial(0xe8e3d4, 0.55, 0.0);
      });

      const box = new THREE.Box3().setFromObject(bunnyRoot);
      const size = new THREE.Vector3();
      box.getSize(size);
      const maxDim = Math.max(size.x, size.y, size.z);
      const s = 1.35 / Math.max(1e-6, maxDim);
      bunnyRoot.scale.setScalar(s);

      const box2 = new THREE.Box3().setFromObject(bunnyRoot);
      const center = new THREE.Vector3();
      box2.getCenter(center);
      bunnyRoot.position.sub(center);

      const box3 = new THREE.Box3().setFromObject(bunnyRoot);
      const minY = box3.min.y;
      bunnyRoot.position.y -= minY;
      bunnyRoot.position.y += pedestal.position.y + pedestalH * 0.5 + 0.02;

      scene.add(bunnyRoot);
      return { bunny: bunnyRoot, pedestal };
    }

    // ============================================================
    // 10) SCREEN DEBUG OVERLAY
    // ============================================================
    const DEBUG_MODES = {
      Off: 0,
      Surfels: 1,
      Normals: 2,
      Depth: 3
    };
    const DEBUG_MODE_LABELS = ['Off', 'Surfels', 'Normals', 'Depth'];

    function createSurfelScreenDebugBruteForce(cellCountsAtomic) {
      let overlayAttr = null;
      let overlayStore = null;
      let quad = null;
      let blitMat = null;
      let blitWidth = 0;
      let blitHeight = 0;

      let debugCompute = null;
      let lastSurfelAttr = null;
      let lastDepthTex = null;
      let lastNormalTex = null;
      let lastPixels = 0;

      const U_PROJ_INV = uniform(new THREE.Matrix4());
      const U_CAM_WORLD = uniform(new THREE.Matrix4());
      const U_CAM_POS = uniform(new THREE.Vector3());
      const U_PREV_GRID_ORIGIN = uniform(new THREE.Vector3());

      const U_TTL = uniform(SURFEL_TTL_DEFAULT);
      const U_MAX_SCAN = uniform(2048);

      const U_BASE_RADIUS = uniform(SURFEL_BASE_RADIUS);
      const U_RADIUS_REF_DIST = uniform(SURFEL_RADIUS_REF_DIST);
      const U_RADIUS_OVERSCALE = uniform(SURFEL_RADIUS_OVERSCALE);
      const U_NORMAL_SQUISH = uniform(SURFEL_NORMAL_DIRECTION_SQUISH);

      const U_MAX_SURFELS_PER_CELL = uniform(64);
      const U_DEBUG_MODE = uniform(DEBUG_MODES.Off);

      const debugParams = { mode: DEBUG_MODES.Off };
      let show = false;

      function setDebugMode(mode) {
        debugParams.mode = mode;
        U_DEBUG_MODE.value = mode;
        show = mode !== DEBUG_MODES.Off;
      }

      function setParams(p) {
        if (p.ttl != null) U_TTL.value = p.ttl;
        if (p.maxScan != null) U_MAX_SCAN.value = p.maxScan;
        if (p.baseRadius != null) U_BASE_RADIUS.value = p.baseRadius;
        if (p.radiusRefDist != null) U_RADIUS_REF_DIST.value = p.radiusRefDist;
        if (p.radiusOverscale != null) U_RADIUS_OVERSCALE.value = p.radiusOverscale;
        if (p.normalSquish != null) U_NORMAL_SQUISH.value = p.normalSquish;
        if (p.maxSurfelsPerCell != null) U_MAX_SURFELS_PER_CELL.value = p.maxSurfelsPerCell;
      }

      function ensureOverlay(width, height) {
        const pixels = width * height;
        const needsResize = !overlayAttr || overlayAttr.count !== pixels || blitWidth !== width || blitHeight !== height;
        if (needsResize) {
          overlayAttr = new THREE.StorageBufferAttribute(new Float32Array(pixels * 4), 4);
          overlayStore = storage(overlayAttr, 'vec4', pixels);
          debugCompute = null;
        }
        if (!quad || !blitMat || blitWidth !== width || blitHeight !== height) {
          ensureBlit(width, height);
        }
        blitWidth = width;
        blitHeight = height;
      }

      function ensureBlit(width, height) {
        blitMat = new THREE.NodeMaterial();
        blitMat.depthTest = false;
        blitMat.depthWrite = false;
        blitMat.transparent = true;
        blitMat.blending = THREE.AdditiveBlending;

        blitMat.colorNode = Fn(() => {
          const Wf = float(width), Hf = float(height);
          const x = uv().x.mul(Wf).floor();
          const y = uv().y.mul(Hf).floor();
          const flat = y.mul(Wf).add(x).toInt();
          const val = overlayStore.element(flat);
          return vec3(val.x, val.y, val.z);
        })();

        blitMat.opacityNode = Fn(() => {
          const Wf = float(width), Hf = float(height);
          const x = uv().x.mul(Wf).floor();
          const y = uv().y.mul(Hf).floor();
          const flat = y.mul(Wf).add(x).toInt();
          return overlayStore.element(flat).w;
        })();

        quad = new THREE.QuadMesh(blitMat);
        quad.frustumCulled = false;
        quad.renderOrder = 9999;
      }

      function run(renderer, camera, gbuffer, pool, prevGridOrigin) {
        if (!show) return;

        const texDepth = gbuffer.target.depthTexture;
        const texNormal = gbuffer.target.textures[0];
        if (!texDepth || !texNormal) return;

        const W = gbuffer.target.width;
        const H = gbuffer.target.height;
        const pixels = Math.max(1, W * H);
        ensureOverlay(W, H);
        if (!overlayStore) return;

        const surfelAttr = pool.getSurfelAttr();
        const poolMax = pool.getPoolMaxAtomic();
        if (!surfelAttr || !poolMax) return;

        U_PROJ_INV.value.copy(camera.projectionMatrixInverse);
        U_CAM_WORLD.value.copy(camera.matrixWorld);
        U_CAM_POS.value.copy(camera.position);
        U_PREV_GRID_ORIGIN.value.copy(prevGridOrigin);

        const needRebuild =
          !debugCompute ||
          surfelAttr !== lastSurfelAttr ||
          texDepth !== lastDepthTex ||
          texNormal !== lastNormalTex ||
          pixels !== lastPixels;

        if (needRebuild) {
          debugCompute = null;
          lastSurfelAttr = surfelAttr;
          lastDepthTex = texDepth;
          lastNormalTex = texNormal;
          lastPixels = pixels;
        }

        if (!debugCompute) {
          const capacity = surfelAttr.count;
          const surfels = storage(surfelAttr, SurfelPacked, capacity);

          const MODE_SURFELS = int(DEBUG_MODES.Surfels);
          const MODE_NORMALS = int(DEBUG_MODES.Normals);
          const MODE_DEPTH = int(DEBUG_MODES.Depth);

          debugCompute = Fn(() => {
            const idx = int(instanceIndex);
            const x = idx.mod(int(W));
            const y = idx.div(int(W));
            const uvCoord = vec2(
              x.toFloat().add(0.5).div(float(W)),
              y.toFloat().add(0.5).div(float(H))
            );

            const depth = texture(texDepth, uvCoord).r;
            const encN = texture(texNormal, uvCoord).xyz;
            const pixelNormal = encN.mul(2.0).sub(1.0).normalize();
            const validDepth = depth.greaterThan(1e-6).and(depth.lessThan(0.999));

            const outC = vec4(0).toVar();

            If(U_DEBUG_MODE.equal(MODE_NORMALS), () => {
              outC.assign(vec4(encN, 1.0));
            });

            If(U_DEBUG_MODE.equal(MODE_DEPTH), () => {
              const d = depth.clamp(0.0, 1.0);
              outC.assign(vec4(d, d, d, 1.0));
            });

            If(U_DEBUG_MODE.equal(MODE_SURFELS), () => {
              const sumR = float(0).toVar();
              const sumG = float(0).toVar();
              const sumB = float(0).toVar();
              const sumW = float(0).toVar();

              If(validDepth, () => {
                const viewPos = getViewPosition(uvCoord, depth, U_PROJ_INV);
                const worldPos = U_CAM_WORLD.mul(vec4(viewPos, 1.0)).xyz;

                // Use same cell hashing + neighbor cap as find pass (best-effort parity)
                const hsh = posToCellHash(worldPos, U_PREV_GRID_ORIGIN).toVar();
                const cnt = atomicAdd(cellCountsAtomic.element(hsh), int(0)).toVar();
                const loopCountWanted = min(cnt, int(U_MAX_SURFELS_PER_CELL).mul(int(2))).toVar();

                const total = atomicAdd(poolMax.element(0), int(0)).toVar();
                const scanCount = min(min(total, int(U_MAX_SCAN)), int(capacity)).toVar();

                const processed = int(0).toVar();

                Loop(scanCount, ({ i }) => {
                  const stillNeed = processed.lessThan(loopCountWanted);
                  If(stillNeed, () => {
                    const sid = int(i);
                    const s = surfels.element(sid);
                    const age = s.get('age');
                    const alive = age.lessThan(int(U_TTL));

                    If(alive, () => {
                      const sPos = s.get('posr').xyz;
                      const sNor = s.get('normal');

                      const sh = posToCellHash(sPos, U_PREV_GRID_ORIGIN);
                      const isSameHash = sh.equal(hsh);

                      If(isSameHash, () => {
                        processed.addAssign(int(1));

                        const distCam = length(sPos.sub(U_CAM_POS));
                        const sRad = float(U_BASE_RADIUS).mul(
                          max(float(1.0), distCam.div(float(U_RADIUS_REF_DIST)))
                        );

                        const dV = worldPos.sub(sPos);
                        const d = length(dV);
                        const alignPenalty = abs(dot(dV, sNor)).mul(float(U_NORMAL_SQUISH));
                        const mahal = d.mul(float(1.0).add(alignPenalty));

                        const dirW = max(float(0.0), dot(sNor, pixelNormal));
                        const w = smoothstep(
                          sRad.mul(float(U_RADIUS_OVERSCALE)),
                          float(0.0),
                          mahal
                        ).mul(dirW);

                        const sidu = uint(sid);
                        const r = uintToU01Float(hash1(sidu));
                        const g = uintToU01Float(hash1(sidu.add(uint(1))));
                        const b = uintToU01Float(hash1(sidu.add(uint(2))));

                        sumR.addAssign(r.mul(w));
                        sumG.addAssign(g.mul(w));
                        sumB.addAssign(b.mul(w));
                        sumW.addAssign(w);
                      });
                    });
                  });
                });

                const alpha = sumW.clamp(0.0, 1.0);
                const invW = sumW.greaterThan(float(0)).select(float(1.0).div(sumW), float(0.0));
                outC.assign(vec4(sumR.mul(invW), sumG.mul(invW), sumB.mul(invW), alpha));
              });
            });

            const flat = y.mul(int(W)).add(x);
            overlayStore.element(flat).assign(outC);
          })().compute(pixels).setName('Surfel Debug (Ref Parity)');
        }

        renderer.compute(debugCompute);
      }

      function renderOverlay(renderer) {
        if (!show || !quad || !blitMat) return;
        const prevAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        quad.render(renderer);
        renderer.autoClear = prevAutoClear;
      }

      return { run, renderOverlay, setDebugMode, setParams, debugParams };
    }

    // ============================================================
    // 11) MAIN
    // ============================================================
    const app = document.getElementById('app');
    const hud = document.getElementById('hud');
    const fallback = document.getElementById('fallback');

    function showFallback(html) {
      fallback.style.display = 'grid';
      fallback.innerHTML = html;
    }

    if (!navigator.gpu) {
      showFallback(`
        <div>
          <h2>WebGPU not available</h2>
          <p>This demo requires a browser with WebGPU enabled.</p>
          <p>Try a recent Chrome/Edge and ensure WebGPU is enabled.</p>
        </div>
      `);
      throw new Error('WebGPU not available');
    }

    const renderer = new THREE.WebGPURenderer({
      antialias: true,
      forceWebGL: false,
      requiredLimits: {
        maxStorageBuffersPerShaderStage: 8,
        maxComputeInvocationsPerWorkgroup: 256
      }
    });

    renderer.inspector = new Inspector();
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.autoClear = true;
    app.appendChild(renderer.domElement);

    await renderer.init();

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.05, 200);

    // CHANGE #1: framing for compact scene
    camera.position.set(3.2, 2.4, 5.0);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.35, 0);
    controls.update();

    camera.layers.enable(0);

    await buildScene(scene);

    // ============================================================
    // POST PROCESSING SETUP
    // ============================================================
    const postProcessing = new THREE.PostProcessing(renderer);

    const scenePass = pass(scene, camera);
    const sceneMRT = mrt({ output: output });
    sceneMRT.setName('sceneMRT')
    scenePass.setMRT(sceneMRT);

    const scenePassColor = scenePass.getTextureNode('output').toInspector('Color');
    postProcessing.outputNode = scenePassColor;

    // GUI params (updated to match reference knobs)
    const params = {
      paused: false,

      // GBuffer
      gbufferScale: 0.25, // CHANGE #1: default lower to keep brute-force viable

      // Pool
      capacity: 2048,     // CHANGE #1: smaller default for brute-force without full grid list

      // Brute-force scanning cap (not in reference; safety for “no grid list” stage)
      maxScan: 2048,

      // Coverage kernel (matches reference)
      baseRadius: SURFEL_BASE_RADIUS,
      radiusRefDist: SURFEL_RADIUS_REF_DIST,
      radiusOverscale: SURFEL_RADIUS_OVERSCALE,
      normalSquish: SURFEL_NORMAL_DIRECTION_SQUISH,

      // Reference grid constants
      maxSurfelsPerCell: 64,
      maxKeepAlive: 32,
      keepAliveCredit: 5,

      // Reference spawn gating
      coverageThreshold: 0.1, // scoringWeight < 0.1
      secondGate: 0.4,        // second < 0.4
      probMult: 5000.0,
      depthDiv: 64.0,

      // Despawn
      despawnEnabled: true,

      // Aging
      ttl: SURFEL_TTL_DEFAULT,
      ageStep: 1,
      forceKill: false,

      // Debug
      debugMode: DEBUG_MODES.Surfels,
      debugHz: 10,

      resetSurfels: () => {},
    };

    function createUI(renderer) {
      if (renderer.inspector && typeof renderer.inspector.createParameters === 'function') {
        return renderer.inspector.createParameters('Surfelization');
      }
      const noopController = {
        name: () => noopController,
        onChange: () => noopController,
        listen: () => noopController
      };
      const noopFolder = {
        add: () => noopController,
        addFolder: () => noopFolder,
        close: () => noopFolder
      };
      return noopFolder;
    }

    const gui = createUI(renderer);

    // Pool + passes
    const pool = createSurfelPool();
    pool.ensureCapacity(params.capacity);

    const resetPass = createSurfelResetPass();
    const agePass = createSurfelAgePass();

    // CHANGE #3: cell count table + ref-parity find pass
    const cellCountPass = createSurfelCellCountPass();
    const findPass = createSurfelFindMissingBruteForcePass(cellCountPass.getCellCountsAtomic());

    const allocPass = createSurfelAllocatePass();

    resetPass.run(renderer, pool);

    const screenDebug = createSurfelScreenDebugBruteForce(cellCountPass.getCellCountsAtomic());
    screenDebug.setDebugMode(params.debugMode);

    params.resetSurfels = () => resetPass.run(renderer, pool);

    // GUI wiring
    {
      const f = gui.addFolder('GBuffer');
      f.add(params, 'gbufferScale', 0.15, 1.0, 0.01);
    }

    {
      const f = gui.addFolder('Pool');
      f.add(params, 'capacity', 512, 65536, 512).name('Max Surfels').onChange((v) => {
        pool.ensureCapacity(v);
        // keep maxScan >= capacity by default
        params.maxScan = Math.max(params.maxScan, v);
        resetPass.run(renderer, pool);
      });
      f.add(params, 'resetSurfels').name('Reset');
    }

    {
      const f = gui.addFolder('Brute Force Scan');
      f.add(params, 'maxScan', 128, 65536, 128).name('Max surfels scanned');
    }

    {
      const f = gui.addFolder('Coverage Kernel');
      f.add(params, 'baseRadius', 0.02, 0.5, 0.005);
      f.add(params, 'radiusRefDist', 0.5, 30.0, 0.1).name('Radius ref dist');
      f.add(params, 'radiusOverscale', 0.5, 3.0, 0.01).name('Radius overscale');
      f.add(params, 'normalSquish', 0.0, 6.0, 0.05).name('Normal squish');
    }

    {
      const f = gui.addFolder('Cell Limits (Ref)');
      f.add(params, 'maxSurfelsPerCell', 8, 256, 1).name('MAX_SURFELS_PER_CELL');
      f.add(params, 'maxKeepAlive', 1, 256, 1).name('KEEP_ALIVE_CELL_MAX');
      f.add(params, 'keepAliveCredit', 0, 20, 1).name('KeepAlive credit');
    }

    {
      const f = gui.addFolder('Spawn (Ref)');
      f.add(params, 'coverageThreshold', 0.0, 1.0, 0.005).name('scoringWeight <');
      f.add(params, 'secondGate', 0.0, 1.0, 0.005).name('second <');
      f.add(params, 'probMult', 0.0, 20000.0, 10.0).name('probMult');
      f.add(params, 'depthDiv', 1.0, 256.0, 1.0).name('depthDiv');
    }

    {
      const f = gui.addFolder('Despawn (Ref)');
      f.add(params, 'despawnEnabled').name('Enabled');
    }

    {
      const f = gui.addFolder('Aging');
      f.add(params, 'ttl', 10, 2000, 1).name('TTL');
      f.add(params, 'ageStep', 0, 5, 1).name('Age step');
      f.add(params, 'forceKill').name('Force kill (debug)');
    }

    {
      const f = gui.addFolder('Debug');
      const debugOptions = {
        Off: DEBUG_MODES.Off,
        Surfels: DEBUG_MODES.Surfels,
        Normals: DEBUG_MODES.Normals,
        Depth: DEBUG_MODES.Depth
      };

      f.add(params, 'debugMode', debugOptions).name('Mode').onChange((v) => {
        params.debugMode = Number(v);
        screenDebug.setDebugMode(params.debugMode);
      });
      f.add(params, 'debugHz', 1, 60, 1).name('Readback Hz');
    }

    gui.add(params, 'paused');

    // GBuffer (separate from PostProcessing, used only for compute passes)
    let gbuffer = createGBuffer(renderer, params.gbufferScale);

    // Readback scheduling
    let lastReadbackMs = 0;
    let readbackInFlight = false;

    let lastAliveCount = 0;
    let lastMaxCount = 0;
    let lastTileCount = 0;

    // CHANGE #3: prev camera tracking for ref parity uniforms
    const prevCameraPos = camera.position.clone();
    const prevGridOrigin = new THREE.Vector3();
    snapToSurfelGridOrigin(prevGridOrigin, prevCameraPos);

    function applyPassParams() {
      agePass.setParams({ ttl: params.ttl, ageStep: params.ageStep, forceKill: params.forceKill });

      cellCountPass.setParams({ ttl: params.ttl });

      findPass.setParams({
        ttl: params.ttl,
        maxScan: params.maxScan,

        baseRadius: params.baseRadius,
        radiusRefDist: params.radiusRefDist,
        radiusOverscale: params.radiusOverscale,
        normalSquish: params.normalSquish,

        maxSurfelsPerCell: params.maxSurfelsPerCell,
        maxKeepAlive: params.maxKeepAlive,
        keepAliveCredit: params.keepAliveCredit,

        coverageThreshold: params.coverageThreshold,
        secondGate: params.secondGate,

        probMult: params.probMult,
        depthDiv: params.depthDiv,

        despawnEnabled: params.despawnEnabled
      });

      screenDebug.setParams({
        ttl: params.ttl,
        maxScan: params.maxScan,
        baseRadius: params.baseRadius,
        radiusRefDist: params.radiusRefDist,
        radiusOverscale: params.radiusOverscale,
        normalSquish: params.normalSquish,
        maxSurfelsPerCell: params.maxSurfelsPerCell
      });
    }

    function resizeAll() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      gbuffer.resize(params.gbufferScale);
    }

    window.addEventListener('resize', resizeAll);

    // ============================================================
    // 12) ANIMATION LOOP
    // ============================================================
    renderer.setAnimationLoop(() => {
      controls.update();

      // lazy gbuffer resize
      if (gbuffer.target) {
        const dpr = renderer.getPixelRatio ? renderer.getPixelRatio() : window.devicePixelRatio;
        const wantW = Math.max(1, Math.floor(window.innerWidth  * dpr * params.gbufferScale));
        const wantH = Math.max(1, Math.floor(window.innerHeight * dpr * params.gbufferScale));
        if (gbuffer.target.width !== wantW || gbuffer.target.height !== wantH) {
          gbuffer.resize(params.gbufferScale);
        }
      }

      applyPassParams();

      if (!params.paused) {
        // --- 1) GBUFFER PASS ---
        const prevTarget = renderer.getRenderTarget();
        renderer.setMRT(gbuffer.sceneMRT);
        renderer.setRenderTarget(gbuffer.target);
        renderer.clear();

        scene.background = null;
        camera.layers.set(0);
        renderer.render(scene, camera);

        renderer.setRenderTarget(prevTarget);
        renderer.setMRT(null);

        // --- 2) CELL COUNT TABLE (for cnt parity) ---
        cellCountPass.run(renderer, pool, prevGridOrigin);

        // --- 3) FIND MISSING (ref parity) ---
        const { tileCount } = findPass.run(renderer, camera, gbuffer, pool, prevCameraPos, prevGridOrigin);
        lastTileCount = tileCount;

        // --- 4) AGE / RECYCLE (consumes touchedAtomic incl. kill signal) ---
        agePass.run(renderer, pool);

        // --- 5) ALLOCATE ---
        allocPass.run(renderer, pool, findPass, tileCount);
      }

      // Update prev-camera state for next frame (ref parity)
      prevCameraPos.copy(camera.position);
      snapToSurfelGridOrigin(prevGridOrigin, prevCameraPos);

      // --- DISPLAY ---
      scene.background = new THREE.Color(0x10131a);
      renderer.setRenderTarget(null);
      renderer.clear();
      postProcessing.render();

      // --- GPU debug overlay ---
      if (params.debugMode !== DEBUG_MODES.Off) {
        screenDebug.run(renderer, camera, gbuffer, pool, prevGridOrigin);
        screenDebug.renderOverlay(renderer);
      }

      // --- CPU readback for numbers only ---
      const now = performance.now();
      const intervalMs = 1000 / Math.max(1, params.debugHz);

      if (!readbackInFlight && (now - lastReadbackMs) >= intervalMs) {
        readbackInFlight = true;
        lastReadbackMs = now;

        pool.readStatsAsync(renderer).then((stats) => {
          if (stats) {
            lastAliveCount = stats[0];
            lastMaxCount = stats[1];
          }
        }).finally(() => {
          readbackInFlight = false;
        });
      }

      hud.textContent =
`WebGPU Surfelization (no grid list, ref-parity logic)
gbuffer: ${gbuffer.target.width}x${gbuffer.target.height} (scale ${params.gbufferScale.toFixed(2)})
tiles:   ${lastTileCount}
debug:   ${DEBUG_MODE_LABELS[params.debugMode]}

alive    ${lastAliveCount} / ${params.capacity} (max ${lastMaxCount})
scanCap  ${params.maxScan}

cell:    CS=${SURFEL_CS}  cell=${SURFEL_GRID_CELL_DIAMETER.toFixed(2)}  keepAliveMax=${params.maxKeepAlive}  cellMax=${params.maxSurfelsPerCell}
kernel:  r=${params.baseRadius.toFixed(3)}  over=${params.radiusOverscale.toFixed(2)}  squish=${params.normalSquish.toFixed(2)}

spawn:   scoring<${params.coverageThreshold.toFixed(2)}  second<${params.secondGate.toFixed(2)}
         probMult=${params.probMult.toFixed(0)}  depthDiv=${params.depthDiv.toFixed(0)}

despawn: ${params.despawnEnabled ? 'on' : 'off'} (kill-signal in touchedAtomic)
ttl ${params.ttl}  ageStep ${params.ageStep}
`;
    });
  </script>
</body>
</html>
