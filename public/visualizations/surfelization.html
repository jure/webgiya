<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGPU Surfelization Playground (Brute Force Coverage)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background:#0b0c10; }
    #app { width: 100%; height: 100%; }
    #hud {
      position: absolute;
      left: 10px; top: 10px;
      padding: 8px 10px;
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: #d7d7d7;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 8px;
      pointer-events: none;
      white-space: pre;
    }
    #fallback {
      position: absolute; inset: 0;
      display: none;
      place-items: center;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      padding: 24px;
    }
    a { color: #9bdcff; }
  </style>

  <!-- Import map so the code can keep your original-style specifiers -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",  
      "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.webgpu.js",
      "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.tsl.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/",
      "lil-gui": "https://esm.sh/lil-gui@0.19.2"
    }
  }
  </script>
</head>

<body>
  <div id="app"></div>
  <div id="hud">Initializing…</div>
  <div id="fallback"></div>

  <script type="module">
    import * as THREE from 'three/webgpu';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { GUI } from 'lil-gui';

    import {
      // --- TSL core ---
      Fn, uniform, storage,
      int, uint, float, vec2, vec3, vec4,
      If, Loop,
      min, max, abs, dot, length, clamp, smoothstep,
      texture, getViewPosition,

      // --- compute/threadgroup bits ---
      workgroupId, localId, workgroupBarrier, workgroupArray,
      atomicAdd, atomicMax, atomicMin, atomicStore, atomicLoad,

      // --- bit ops & packing ---
      bitAnd, bitOr, bitcast, floatBitsToUint,

      // --- MRT nodes ---
      mrt, normalWorldGeometry, diffuseColor,
      instancedArray, struct, instanceIndex, color
    } from 'three/tsl';

    // ============================================================
    // 0) CONFIG
    // ============================================================
    const MODEL_URL = '../models/bunny.glb'; // <--- put bunny.glb next to this html (or change path)

    const SURFEL_DEAD = 0x7fffffff; // sentinel for recycled surfels (int32 max-ish)

    // Workgroup tile = 8x8 pixels (matches your original mental model)
    const TILE_X = 8;
    const TILE_Y = 8;

    // ============================================================
    // 1) MATERIAL HELPERS (Node Materials so MRT/diffuseColor behaves)
    // ============================================================
    function makeNodeStandard(hex, roughness = 0.85, metalness = 0.0) {
        const mat = new THREE.MeshStandardMaterial({
            color: hex,
            roughness: roughness,
            metalness: metalness
        });
        return mat;
    }

    // ============================================================
    // 2) GBUFFER (Normal + Diffuse + Depth)
    // ============================================================
    function createGBuffer(renderer, scale) {
      const dpr = renderer.getPixelRatio ? renderer.getPixelRatio() : window.devicePixelRatio;
      const w = Math.max(1, Math.floor(window.innerWidth  * dpr * scale));
      const h = Math.max(1, Math.floor(window.innerHeight * dpr * scale));

      const target = new THREE.RenderTarget(w, h, {
        count: 2,
        type: THREE.HalfFloatType,
        format: THREE.RGBAFormat,
        depthBuffer: true
      });

      target.depthTexture = new THREE.DepthTexture(w, h);
      target.textures[0].name = 'gbuf_normal';
      target.textures[1].name = 'gbuf_albedo';

      for (let i = 0; i < 2; i++) {
        target.textures[i].generateMipmaps = false;
        target.textures[i].magFilter = THREE.NearestFilter;
        target.textures[i].minFilter = THREE.NearestFilter;
      }

      // Encode normals to 0..1 for storage
      const sceneMRT = mrt({
        normal: normalWorldGeometry.mul(0.5).add(0.5),
        albedo: vec4(diffuseColor.rgb, 1.0)
      });

      function resize(newScale) {
        const dpr = renderer.getPixelRatio ? renderer.getPixelRatio() : window.devicePixelRatio;
        const w = Math.max(1, Math.floor(window.innerWidth  * dpr * newScale));
        const h = Math.max(1, Math.floor(window.innerHeight * dpr * newScale));
        target.setSize(w, h);
      }

      return { target, sceneMRT, resize };
    }

    // ============================================================
    // 3) HASH / RANDOM (copied + trimmed from your hashUtils.ts)
    // ============================================================
    const hash1 = Fn(([x_in]) => {
      let x = uint(x_in).toVar();
      x.addAssign(x.shiftLeft(10));
      x.bitXorAssign(x.shiftRight(6));
      x.addAssign(x.shiftLeft(3));
      x.bitXorAssign(x.shiftRight(11));
      x.addAssign(x.shiftLeft(15));
      return x;
    });

    const hashCombine2 = Fn(([x, y]) => {
      const M = uint(1664525);
      const C = uint(1013904223);
      let seed = x.mul(M).add(y).add(C).mul(M).toVar();
      seed.bitXorAssign(seed.shiftRight(11));
      seed.bitXorAssign(seed.shiftLeft(7).bitAnd(uint(0x9d2c5680)));
      seed.bitXorAssign(seed.shiftLeft(15).bitAnd(uint(0xefc60000)));
      seed.bitXorAssign(seed.shiftRight(18));
      return seed;
    });

    const uintToU01Float = Fn(([h_in]) => {
      let h = uint(h_in).toVar();
      const mantissaMask = uint(0x007FFFFF);
      const one = uint(0x3F800000);
      h.bitAndAssign(mantissaMask);
      h.bitOrAssign(one);
      const r = bitcast(h, 'float');
      return r.sub(1.0);
    });

    // ============================================================
    // 4) SURFEL POOL (just pos+normal+age + free-stack + atomics)
    // ============================================================
    // const SurfelStruct = Fn(() => {})(); // dummy so we can declare struct below (TSL struct API differs by revision)
    // Use TSL struct() the same way your code does:
    // NOTE: in some three versions, `struct` is in 'three/tsl'. If your build errors here,
    // change the import to include `struct` and use it exactly like your original code.
    // For maximum compatibility with your posted code, we’ll pull it from THREE via webgpu build:
    const SurfelPacked = struct({
      posr: 'vec4',
      normal: 'vec3',
      age: 'int'
    }, 'SurfelPacked');

    function createSurfelPool() {
      let capacity = 0;

      let surfelAttr = null;     // StorageBufferAttribute (itemSize 8)
      let poolAttr = null;       // StorageInstancedBufferAttribute (int stack)
      let touchedAtomic = null;  // StorageBufferNode (atomic int per surfel)
      let poolAllocAtomic = null; // StorageBufferNode (atomic int)
      let poolMaxAtomic = null;   // StorageBufferNode (atomic int)

      // Debug readback: 2x vec4 per surfel
      let dbgAttr = null;
      let dbgStore = null;
      let dbgCopyNode = null;

      function ensureCapacity(nextCap) {
        if (capacity === nextCap && surfelAttr) return;
        capacity = nextCap;

        // Surfel buffer: 8 floats per surfel
        surfelAttr = new THREE.StorageBufferAttribute(new Float32Array(capacity * 8), 8);

        // Free stack (pool[i] = i)
        const poolIdx = new Int32Array(capacity);
        for (let i = 0; i < capacity; i++) poolIdx[i] = i;
        poolAttr = new THREE.StorageInstancedBufferAttribute(poolIdx, 1);
        poolAttr.needsUpdate = true;

        // Atomics
        poolAllocAtomic = instancedArray(new Int32Array(1), 'int').toAtomic();
        poolMaxAtomic   = instancedArray(new Int32Array(1), 'int').toAtomic();
        touchedAtomic   = instancedArray(new Int32Array(capacity), 'int').toAtomic();

        // Debug readback buffer (vec4 * (capacity*2))
        const dbg = new Float32Array(capacity * 8); // capacity * 2 vec4
        dbgAttr = new THREE.StorageInstancedBufferAttribute(dbg, 4);
        dbgStore = storage(dbgAttr, 'vec4', capacity * 2);
        dbgCopyNode = null;
      }

      function getCapacity() { return capacity; }
      function getSurfelAttr() { return surfelAttr; }
      function getPoolAttr() { return poolAttr; }
      function getTouchedAtomic() { return touchedAtomic; }
      function getPoolAllocAtomic() { return poolAllocAtomic; }
      function getPoolMaxAtomic() { return poolMaxAtomic; }
      function invalidateDebugCopy() { dbgCopyNode = null; }

      async function readbackAsync(renderer) {
        if (!surfelAttr || !dbgAttr || !dbgStore) return null;
        const cap = capacity;

        // Build the GPU copy pass once (or rebuild if capacity changed)
        if (!dbgCopyNode) {
          const surfels = storage(surfelAttr, SurfelPacked, cap);

          dbgCopyNode = Fn(() => {
            const i = int(instanceIndex);
            const s = surfels.element(i);
            // vec4 #0: posr (xyz + birthFrame)
            dbgStore.element(i.mul(2)).assign(s.get('posr'));
            // vec4 #1: normal.xyz + age (as float)
            dbgStore.element(i.mul(2).add(1)).assign(vec4(
              s.get('normal'),
              float(s.get('age'))
            ));
          })().compute(cap).setName('Surfel Debug Copy');
        }

        await renderer.compute(dbgCopyNode);
        const ab = await renderer.getArrayBufferAsync(dbgAttr);
        return new Float32Array(ab);
      }

      return {
        ensureCapacity,
        getCapacity,
        getSurfelAttr,
        getPoolAttr,
        getTouchedAtomic,
        getPoolAllocAtomic,
        getPoolMaxAtomic,
        readbackAsync,
        invalidateDebugCopy
      };
    }

    // ============================================================
    // 5) RESET / INIT POOL (clear surfels, reset alloc/max, clear touched)
    // ============================================================
    function createSurfelResetPass() {
      let initNode = null;
      let metaNode = null;

      function run(renderer, pool) {
        const cap = pool.getCapacity();
        const surfelAttr = pool.getSurfelAttr();
        const poolAttr = pool.getPoolAttr();
        const poolAlloc = pool.getPoolAllocAtomic();
        const poolMax = pool.getPoolMaxAtomic();
        const touched = pool.getTouchedAtomic();

        if (!surfelAttr || !poolAttr || !poolAlloc || !poolMax || !touched) return;

        const surfels = storage(surfelAttr, SurfelPacked, cap);
        const poolBuf = storage(poolAttr, 'int', cap);

        if (!initNode) {
          initNode = Fn(() => {
            const i = int(instanceIndex);

            // clear surfel
            surfels.element(i).get('posr').assign(vec4(0, 0, 0, 0));
            surfels.element(i).get('normal').assign(vec3(0, 1, 0));
            surfels.element(i).get('age').assign(int(SURFEL_DEAD));

            // refill free stack
            poolBuf.element(i).assign(i);

            // clear touched
            atomicStore(touched.element(i), int(0));
          })().compute(cap).setName('Surfel Reset Init');
        }

        if (!metaNode) {
          metaNode = Fn(() => {
            atomicStore(poolAlloc.element(int(0)), int(0));
            atomicStore(poolMax.element(int(0)), int(0));
          })().compute(1).setName('Surfel Reset Meta');
        }

        renderer.compute(initNode);
        renderer.compute(metaNode);

        pool.invalidateDebugCopy();
      }

      return { run };
    }

    // ============================================================
    // 6) AGE / RECYCLE PASS (TTL + keepalive credit from touched[])
    // ============================================================
    function createSurfelAgePass() {
      let node = null;

      // Uniforms (interactive)
      const U_TTL = uniform(300);               // int-ish
      const U_AGE_STEP = uniform(1);            // int-ish
      const U_FORCE_KILL = uniform(false);      // debug toggle

      function setParams({ ttl, ageStep, forceKill }) {
        if (ttl != null) U_TTL.value = ttl;
        if (ageStep != null) U_AGE_STEP.value = ageStep;
        if (forceKill != null) U_FORCE_KILL.value = forceKill;
      }

      function run(renderer, pool) {
        const cap = pool.getCapacity();
        const surfelAttr = pool.getSurfelAttr();
        const poolAttr = pool.getPoolAttr();
        const poolAlloc = pool.getPoolAllocAtomic();
        const poolMax = pool.getPoolMaxAtomic();
        const touched = pool.getTouchedAtomic();

        if (!surfelAttr || !poolAttr || !poolAlloc || !poolMax || !touched) return;

        // rebuild if capacity changes
        if (!node || node.__cap !== cap) {
          const surfels = storage(surfelAttr, SurfelPacked, cap);
          const poolBuf = storage(poolAttr, 'int', cap);

          node = Fn(() => {
            const idx = int(instanceIndex);
            const total = atomicAdd(poolMax.element(int(0)), int(0));
            const inRange = idx.lessThan(total);

            If(inRange, () => {
              const s = surfels.element(idx);
              const ageNode = s.get('age');
              let ageNow = int(ageNode).toVar();

              const alive = ageNow.lessThan(int(U_TTL));
              If(alive, () => {
                // Read + reset touched credit (atomicMin(val,0) => reads val and sets to 0 if val>0)
                const income = atomicMin(touched.element(idx), int(0)).toVar();

                // Optional debug: force kill everything
                If(U_FORCE_KILL, () => {
                  ageNow.assign(int(U_TTL));
                  ageNode.assign(int(U_TTL));
                }).Else(() => {
                  const step = int(U_AGE_STEP);

                  // age += max(step - income, 0)
                  const delta = max(int(0), step.sub(income));
                  const nextAge = max(int(0), ageNow.add(delta));

                  ageNow.assign(nextAge);
                  ageNode.assign(nextAge);
                });

                // recycle when age >= TTL
                If(ageNow.greaterThanEqual(int(U_TTL)), () => {
                  ageNode.assign(int(SURFEL_DEAD));

                  // push back into free stack: allocCount--, poolBuf[allocCount-1] = idx
                  const oldAlloc = atomicAdd(poolAlloc.element(int(0)), int(-1));
                  const slot = oldAlloc.sub(int(1));
                  // guard in case of underflow (shouldn't happen, but nice for tutorial robustness)
                  If(slot.greaterThanEqual(int(0)).and(slot.lessThan(int(cap))), () => {
                    poolBuf.element(slot).assign(idx);
                  });
                });
              });
            });
          })().compute(cap).setName('Surfel Age/Recycling');

          node.__cap = cap;
        }

        renderer.compute(node);
      }

      return { run, setParams, U_TTL };
    }

    // ============================================================
    // 7) FIND MISSING (BRUTE FORCE COVERAGE, NO GRID)
    //    Output: tileAlloc[2*tile + 0] = spawnFlag (0/1)
    //            tileAlloc[2*tile + 1] = reserved (unused)
    //            candPos[tile] = vec4(worldPos, 1)
    //            candNor[tile] = vec4(worldNormal, 1)
    // ============================================================
    function createSurfelFindMissingBruteForcePass() {
      const U_FRAME = uniform(0);
      const U_PROJ_INV = uniform(new THREE.Matrix4());
      const U_CAM_WORLD = uniform(new THREE.Matrix4());
      const U_CAM_POS = uniform(new THREE.Vector3());

      const U_SCREEN_SIZE = uniform(new THREE.Vector2());
      const U_GRID_STRIDE = uniform(1); // tile grid width

      // Surfels & coverage tuning (interactive)
      const U_TTL = uniform(300);
      const U_MAX_CHECK = uniform(512);              // how many surfels to iterate per pixel (brute-force cap)
      const U_BASE_RADIUS = uniform(0.10);
      const U_RADIUS_REF_DIST = uniform(6.0);
      const U_RADIUS_OVERSCALE = uniform(1.25);
      const U_NORMAL_SQUISH = uniform(2.0);

      const U_COVERAGE_THRESHOLD = uniform(0.12);    // if coverage below => eligible
      const U_KEEPALIVE_THRESHOLD = uniform(0.05);   // if bestWeight above => touch surfel
      const U_KEEPALIVE_CREDIT = uniform(2);         // int credit

      const U_SPAWN_PROB = uniform(0.004);           // per-tile *candidate* probability
      const U_DEPTH_REF = uniform(10.0);             // depth scaling for probability

      // Outputs (resized to tileCount; keep object identity stable where possible)
      const tileAllocAttr = new THREE.StorageBufferAttribute(new Int32Array(2), 1);
      const candPosAttr = new THREE.StorageBufferAttribute(new Float32Array(4), 4);
      const candNorAttr = new THREE.StorageBufferAttribute(new Float32Array(4), 4);

      let computeNode = null;
      let lastTileCount = -1;
      let lastSurfelAttr = null;
      let lastDepthTex = null;
      let lastNormalTex = null;

      function ensureTileBuffers(tileCount) {
        const needed = Math.max(1, tileCount);

        // 2 ints per tile
        if (tileAllocAttr.count < needed * 2) {
          tileAllocAttr.array = new Int32Array(needed * 2);
          tileAllocAttr.count = needed * 2;
          tileAllocAttr.needsUpdate = true;
        }
        if (candPosAttr.count < needed) {
          candPosAttr.array = new Float32Array(needed * 4);
          candPosAttr.count = needed;
          candPosAttr.needsUpdate = true;
        }
        if (candNorAttr.count < needed) {
          candNorAttr.array = new Float32Array(needed * 4);
          candNorAttr.count = needed;
          candNorAttr.needsUpdate = true;
        }
      }

      function setParams(p) {
        if (p.ttl != null) U_TTL.value = p.ttl;
        if (p.maxCheck != null) U_MAX_CHECK.value = p.maxCheck;
        if (p.baseRadius != null) U_BASE_RADIUS.value = p.baseRadius;
        if (p.radiusRefDist != null) U_RADIUS_REF_DIST.value = p.radiusRefDist;
        if (p.radiusOverscale != null) U_RADIUS_OVERSCALE.value = p.radiusOverscale;
        if (p.normalSquish != null) U_NORMAL_SQUISH.value = p.normalSquish;
        if (p.coverageThreshold != null) U_COVERAGE_THRESHOLD.value = p.coverageThreshold;
        if (p.keepAliveThreshold != null) U_KEEPALIVE_THRESHOLD.value = p.keepAliveThreshold;
        if (p.keepAliveCredit != null) U_KEEPALIVE_CREDIT.value = p.keepAliveCredit;
        if (p.spawnProb != null) U_SPAWN_PROB.value = p.spawnProb;
        if (p.depthRef != null) U_DEPTH_REF.value = p.depthRef;
      }

      function run(renderer, camera, gbuffer, pool) {
        const surfelAttr = pool.getSurfelAttr();
        const poolMax = pool.getPoolMaxAtomic();
        const touched = pool.getTouchedAtomic();

        const texDepth = gbuffer.target.depthTexture;
        const texNormal = gbuffer.target.textures[0];

        if (!surfelAttr || !poolMax || !touched || !texDepth || !texNormal) return { tileCount: 0 };

        const w = gbuffer.target.width;
        const h = gbuffer.target.height;

        const tileW = Math.max(1, Math.ceil(w / TILE_X));
        const tileH = Math.max(1, Math.ceil(h / TILE_Y));
        const tileCount = tileW * tileH;

        ensureTileBuffers(tileCount);

        // Update uniforms
        U_FRAME.value = renderer.info.frame;
        U_PROJ_INV.value.copy(camera.projectionMatrixInverse);
        U_CAM_WORLD.value.copy(camera.matrixWorld);
        U_CAM_POS.value.copy(camera.position);
        U_SCREEN_SIZE.value.set(w, h);
        U_GRID_STRIDE.value = tileW;

        // Rebuild compute graph if:
        // - tileCount changes
        // - surfelAttr object changes (capacity reset)
        // - depth/normal texture object changes (rare, but can happen on resize)
        const mustRebuild =
          (tileCount !== lastTileCount) ||
          (surfelAttr !== lastSurfelAttr) ||
          (texDepth !== lastDepthTex) ||
          (texNormal !== lastNormalTex);

        if (mustRebuild) {
          computeNode = null;
          lastTileCount = tileCount;
          lastSurfelAttr = surfelAttr;
          lastDepthTex = texDepth;
          lastNormalTex = texNormal;
        }

        if (!computeNode) {
          const cap = surfelAttr.count;
          const surfels = storage(surfelAttr, SurfelPacked, cap);

          const tileAlloc = storage(tileAllocAttr, 'int', tileAllocAttr.count);
          const candPos = storage(candPosAttr, 'vec4', candPosAttr.count);
          const candNor = storage(candNorAttr, 'vec4', candNorAttr.count);

          // group-shared atomic to pick best lane
          // (atomic<u32> so we can use atomicMin)
          const computeLogic = Fn(() => {
            const gx = workgroupId.x.toInt();
            const gy = workgroupId.y.toInt();
            const lx = localId.x.toInt();
            const ly = localId.y.toInt();

            const lane = ly.mul(int(TILE_X)).add(lx);
            const tileIndex = gy.mul(int(U_GRID_STRIDE)).add(gx);

            const gs_best = workgroupArray('atomic<u32>', 1);

            // lane 0 initializes tile outputs + shared atomic
            If(lane.equal(int(0)), () => {
              const base = tileIndex.mul(int(2));
              tileAlloc.element(base).assign(int(0));
              tileAlloc.element(base.add(int(1))).assign(int(0));
              candPos.element(tileIndex).assign(vec4(0,0,0,0));
              candNor.element(tileIndex).assign(vec4(0,0,1,0));
              atomicStore(gs_best.element(int(0)), uint(0xFFFFFFFF));
            });

            workgroupBarrier();

            const widthF  = U_SCREEN_SIZE.x;
            const heightF = U_SCREEN_SIZE.y;
            const widthI  = int(widthF);
            const heightI = int(heightF);

            const px = gx.mul(int(TILE_X)).add(lx);
            const py = gy.mul(int(TILE_Y)).add(ly);
            const inBounds = px.lessThan(widthI).and(py.lessThan(heightI));

            // Per-lane locals (so the winner can write them)
            const worldPos = vec3(0).toVar();
            const normalW  = vec3(0,1,0).toVar();
            const coverage = float(1e9).toVar();   // score to minimize
            const bestSid  = int(-1).toVar();
            const bestW    = float(0.0).toVar();

            If(inBounds, () => {
              const uv = vec2(
                px.toFloat().add(0.5).div(widthF),
                py.toFloat().add(0.5).div(heightF)
              );

              const depth = texture(texDepth, uv).r;
              const valid = depth.greaterThan(1e-6).and(depth.lessThan(0.999));

              If(valid, () => {
                const viewPos = getViewPosition(uv, depth, U_PROJ_INV);
                const worldPos4 = U_CAM_WORLD.mul(vec4(viewPos, 1.0));
                worldPos.assign(worldPos4.xyz);

                const encN = texture(texNormal, uv).xyz;
                normalW.assign(encN.mul(2.0).sub(1.0).normalize());

                // brute-force coverage against first N surfels
                const total = atomicAdd(poolMax.element(int(0)), int(0));
                const loopCount = int(10); //min(total, int(U_MAX_CHECK));

                const sum = float(0.0).toVar();

                Loop(loopCount, ({ i }) => {
                  const sid = int(i);
                  const s = surfels.element(sid);

                  const age = s.get('age');
                  const alive = age.lessThan(int(U_TTL));

                  If(alive, () => {
                    const sPos = s.get('posr').xyz;
                    const sNor = s.get('normal');

                    // radius scaling with distance-to-camera (simple, tunable)
                    const distCam = length(sPos.sub(U_CAM_POS));
                    const sRad = float(U_BASE_RADIUS).mul(
                      max(float(1.0), distCam.div(float(U_RADIUS_REF_DIST)))
                    );

                    const dV = worldPos.sub(sPos);
                    const d  = length(dV);

                    // Normal-direction squish like your original mahalanobis idea
                    const alignPenalty = abs(dot(dV, sNor)).mul(float(U_NORMAL_SQUISH));
                    const mahal = d.mul(float(1.0).add(alignPenalty));

                    const dirW = max(float(0.0), dot(sNor, normalW));
                    const w = smoothstep(
                      sRad.mul(float(U_RADIUS_OVERSCALE)),
                      float(0.0),
                      mahal
                    ).mul(dirW);

                    sum.addAssign(w);

                    If(w.greaterThan(bestW), () => {
                      bestW.assign(w);
                      bestSid.assign(sid);
                    });
                  });
                });

                // Keepalive: touch the best contributing surfel for this pixel
                If(bestSid.greaterThanEqual(int(0)).and(bestW.greaterThan(float(U_KEEPALIVE_THRESHOLD))), () => {
                  atomicMax(touched.element(bestSid), int(U_KEEPALIVE_CREDIT));
                });

                // Decide if this pixel is a spawn candidate
                // (We select the MIN coverage candidate inside the tile)
                const eligible = sum.lessThan(float(U_COVERAGE_THRESHOLD));

                // Per-candidate random (tile-eligible gating)
                const seed = hashCombine2(
                  hashCombine2(uint(px), hash1(uint(py))),
                  uint(U_FRAME)
                );
                const r = uintToU01Float(seed);

                // Depth-based probability (optional): more spawn in farther pixels
                const viewDepth = viewPos.z.negate(); // positive distance
                const depthFactor = clamp(viewDepth.div(float(U_DEPTH_REF)), 0.0, 1.0);
                const prob = float(U_SPAWN_PROB).mul(depthFactor.max(0.05)); // keep some chance near camera

                const randomOk = r.lessThan(prob);

                // Score for selection: coverage if eligible+randomOk else INF
                const score = eligible.and(randomOk).select(sum, float(1e9));
                coverage.assign(score);

                // Vote: atomicMin on packed floatbits + lane index
                // Keep score in high bits, store lane in low 6 bits
                const scoreBits = floatBitsToUint(score);
                const packed = bitOr(
                  bitAnd(scoreBits, uint(0xFFFFFFC0)),
                  uint(lane)
                );
                atomicMin(gs_best.element(int(0)), packed);
              });
            });

            workgroupBarrier();

            // Winner writes spawn request + candidate position/normal
            const bestPacked = atomicLoad(gs_best.element(int(0)));
            If(bestPacked.notEqual(uint(0xFFFFFFFF)), () => {
              const winningLane = bitAnd(bestPacked, uint(63)).toInt();

              If(lane.equal(winningLane), () => {
                const base = tileIndex.mul(int(2));
                tileAlloc.element(base).assign(int(1));
                tileAlloc.element(base.add(int(1))).assign(int(0));

                candPos.element(tileIndex).assign(vec4(worldPos, 1.0));
                candNor.element(tileIndex).assign(vec4(normalW, 1.0));
              });
            });
          });

          computeNode = computeLogic()
            .computeKernel([TILE_X, TILE_Y, 1])
            .setName('Find Missing (Brute Force)');
        }

        renderer.compute(computeNode, [tileW, tileH, 1]);
        return { tileCount };
      }

      return {
        run,
        setParams,
        getTileAllocAttr: () => tileAllocAttr,
        getCandPosAttr: () => candPosAttr,
        getCandNorAttr: () => candNorAttr
      };
    }

    // ============================================================
    // 8) ALLOCATE PASS (consume tileAlloc + candidate buffers)
    // ============================================================
    function createSurfelAllocatePass() {
      const U_FRAME = uniform(0);
      let node = null;
      let lastTileCount = -1;
      let lastCap = -1;

      function run(renderer, pool, find, tileCount) {
        if (tileCount <= 0) return;

        const cap = pool.getCapacity();
        const surfelAttr = pool.getSurfelAttr();
        const poolAttr = pool.getPoolAttr();
        const poolAlloc = pool.getPoolAllocAtomic();
        const poolMax = pool.getPoolMaxAtomic();

        const tileAllocAttr = find.getTileAllocAttr();
        const candPosAttr = find.getCandPosAttr();
        const candNorAttr = find.getCandNorAttr();

        if (!surfelAttr || !poolAttr || !poolAlloc || !poolMax || !tileAllocAttr || !candPosAttr || !candNorAttr) return;

        U_FRAME.value = renderer.info.frame;

        // Rebuild if tileCount or cap changes (buffer counts are baked into storage() bindings)
        if (!node || lastTileCount !== tileCount || lastCap !== cap) {
          lastTileCount = tileCount;
          lastCap = cap;

          const surfels = storage(surfelAttr, SurfelPacked, cap);
          const poolBuf = storage(poolAttr, 'int', cap);

          const tileAlloc = storage(tileAllocAttr, 'int', tileAllocAttr.count);
          const candPos = storage(candPosAttr, 'vec4', candPosAttr.count);
          const candNor = storage(candNorAttr, 'vec4', candNorAttr.count);

          node = Fn(() => {
            const tile = int(instanceIndex);
            const base = tile.mul(int(2));
            const spawnFlag = tileAlloc.element(base);

            If(spawnFlag.equal(int(1)), () => {
              // pop from free-stack
              const prevAlloc = atomicAdd(poolAlloc.element(int(0)), int(1));
              const within = prevAlloc.lessThan(int(cap));

              If(within, () => {
                const surfelIdx = poolBuf.element(prevAlloc);

                // update high-water mark
                atomicMax(poolMax.element(int(0)), surfelIdx.add(int(1)));

                // write surfel
                const p = candPos.element(tile);
                const n = candNor.element(tile).xyz.normalize();

                const s = surfels.element(surfelIdx);
                s.get('posr').assign(vec4(p.xyz, float(U_FRAME))); // birth frame in w
                s.get('normal').assign(n);
                s.get('age').assign(int(0));
              }).Else(() => {
                // undo alloc increment if overflow
                atomicAdd(poolAlloc.element(int(0)), int(-1));
              });
            });
          })().compute(tileCount).setName('Surfel Allocate');
        }

        renderer.compute(node);
      }

      return { run };
    }

    // ============================================================
    // 9) SCENE: "Bunny in a box"
    // ============================================================
    async function buildScene(scene) {
      scene.background = new THREE.Color(0x10131a);

      // Lights
      const hemi = new THREE.HemisphereLight(0xffffff, 0x223344, 0.35);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 2.5);
      dir.position.set(3, 6, 2);
      dir.castShadow = false;
      scene.add(dir);

      // Floor + walls (simple Cornell-ish)
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(8, 8),
        makeNodeStandard(0xb7b7b7, 0.95, 0.0)
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = 0;
      scene.add(floor);

      function wall(w, h, pos, rotY, hex) {
        const m = new THREE.Mesh(
          new THREE.PlaneGeometry(w, h),
          makeNodeStandard(hex, 0.95, 0.0)
        );
        m.position.copy(pos);
        m.rotation.y = rotY;
        scene.add(m);
      }

      const H = 4;
      wall(8, H, new THREE.Vector3(0, H/2, -4), 0,           0xa7a7a7);
      wall(8, H, new THREE.Vector3(0, H/2,  4), Math.PI,     0xa0a0a0);
      wall(8, H, new THREE.Vector3(-4, H/2, 0), Math.PI/2,   0xff6a6a);
      wall(8, H, new THREE.Vector3( 4, H/2, 0), -Math.PI/2,  0x6a8cff);

      // Bunny
      const loader = new GLTFLoader();
      let bunnyRoot = null;

      try {
        const gltf = await loader.loadAsync(MODEL_URL);
        bunnyRoot = gltf.scene;
      } catch (e) {
        console.warn('Failed to load bunny.glb. Falling back to a sphere.', e);
        const fallback = new THREE.Mesh(
          new THREE.SphereGeometry(0.8, 48, 32),
          makeNodeStandard(0xe8e3d4, 0.6, 0.0)
        );
        fallback.position.set(0, 0.8, 0);
        scene.add(fallback);
        return { bunny: fallback };
      }

      // Replace materials with node materials (keeps MRT/diffuseColor predictable)
      bunnyRoot.traverse((o) => {
        if (o && o.isMesh) {
          o.material = makeNodeStandard(0xe8e3d4, 0.55, 0.0);
        }
      });

      // Normalize scale & place
      const box = new THREE.Box3().setFromObject(bunnyRoot);
      const size = new THREE.Vector3();
      box.getSize(size);
      const maxDim = Math.max(size.x, size.y, size.z);
      const s = 1.6 / Math.max(1e-6, maxDim);
      bunnyRoot.scale.setScalar(s);

      bunnyRoot.position.set(0, 0, 0);
      // re-center after scaling
      const box2 = new THREE.Box3().setFromObject(bunnyRoot);
      const center = new THREE.Vector3();
      box2.getCenter(center);
      bunnyRoot.position.sub(center);
      bunnyRoot.position.y = 0.0;

      scene.add(bunnyRoot);

      return { bunny: bunnyRoot };
    }

    // ============================================================
    // 10) VISUALIZATION: instanced surfel spheres + optional normal lines
    // ============================================================
    function createSurfelDebugMeshes(scene, capacity) {
      const sphereGeo = new THREE.SphereGeometry(1, 10, 8);
      const mat = new THREE.MeshBasicMaterial({ color: 0x00ffd5, transparent: true, opacity: 0.9 });
      const mesh = new THREE.InstancedMesh(sphereGeo, mat, capacity);
      mesh.frustumCulled = false;
      mesh.layers.set(1);
      mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

      // per-instance color
      mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(capacity * 3), 3);
      mesh.instanceColor.setUsage(THREE.DynamicDrawUsage);

      // normal lines (optional)
      const lineGeo = new THREE.BufferGeometry();
      const linePos = new Float32Array(capacity * 2 * 3); // 2 points per surfel
      lineGeo.setAttribute('position', new THREE.BufferAttribute(linePos, 3));
      const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.75 });
      const lines = new THREE.LineSegments(lineGeo, lineMat);
      lines.frustumCulled = false;
      lines.layers.set(1);

      scene.add(mesh);
      scene.add(lines);

      const dummy = new THREE.Object3D();
      const c = new THREE.Color();

      function updateFromReadback(arr, ttl, visualRadius, showNormals, normalLen) {
        // arr layout:
        // vec4 posr for surfel i => arr[(i*2+0)*4 + 0..3]
        // vec4 (normal.xyz, ageFloat) => arr[(i*2+1)*4 + 0..3]
        const instColors = mesh.instanceColor.array;
        const positions = lines.geometry.attributes.position.array;

        let aliveCount = 0;

        for (let i = 0; i < capacity; i++) {
          const base0 = (i * 2 + 0) * 4;
          const base1 = (i * 2 + 1) * 4;

          const px = arr[base0 + 0];
          const py = arr[base0 + 1];
          const pz = arr[base0 + 2];

          const nx = arr[base1 + 0];
          const ny = arr[base1 + 1];
          const nz = arr[base1 + 2];
          const age = arr[base1 + 3];

          const alive = (age >= 0) && (age < ttl);

          if (alive) {
            aliveCount++;

            dummy.position.set(px, py, pz);
            dummy.scale.setScalar(visualRadius);
            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);

            // color by normal (nice for 3D intuition)
            c.setRGB(nx * 0.5 + 0.5, ny * 0.5 + 0.5, nz * 0.5 + 0.5);
            mesh.setColorAt(i, c);

            // normals line
            const l0 = i * 6;
            positions[l0 + 0] = px;
            positions[l0 + 1] = py;
            positions[l0 + 2] = pz;
            positions[l0 + 3] = px + nx * normalLen;
            positions[l0 + 4] = py + ny * normalLen;
            positions[l0 + 5] = pz + nz * normalLen;
          } else {
            // hide: scale 0 + collapse line
            dummy.position.set(0, -99999, 0);
            dummy.scale.setScalar(0);
            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);

            const l0 = i * 6;
            positions[l0 + 0] = 0;
            positions[l0 + 1] = -99999;
            positions[l0 + 2] = 0;
            positions[l0 + 3] = 0;
            positions[l0 + 4] = -99999;
            positions[l0 + 5] = 0;
          }
        }

        mesh.instanceMatrix.needsUpdate = true;
        mesh.instanceColor.needsUpdate = true;

        lines.visible = !!showNormals;
        lines.geometry.attributes.position.needsUpdate = true;

        return aliveCount;
      }

      return { mesh, lines, updateFromReadback };
    }

    // ============================================================
    // 11) MAIN
    // ============================================================
    const app = document.getElementById('app');
    const hud = document.getElementById('hud');
    const fallback = document.getElementById('fallback');

    function showFallback(html) {
      fallback.style.display = 'grid';
      fallback.innerHTML = html;
    }

    // WebGPU availability check
    if (!navigator.gpu) {
      showFallback(`
        <div>
          <h2>WebGPU not available</h2>
          <p>This demo requires a browser with WebGPU enabled.</p>
          <p>Try a recent Chrome/Edge and ensure WebGPU is enabled.</p>
        </div>
      `);
      throw new Error('WebGPU not available');
    }

    // Renderer
    const renderer = new THREE.WebGPURenderer({
      antialias: true,
      forceWebGL: false,
      requiredLimits: {
        maxStorageBuffersPerShaderStage: 8,
        maxComputeInvocationsPerWorkgroup: 256
      }
    });

    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    app.appendChild(renderer.domElement);

    await renderer.init();

    // Scene + Camera + Controls
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.05, 200);
    camera.position.set(4, 3.0, 6.5);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.0, 0);
    controls.update();

    // Two layers: 0 = scene geometry (gbuffer uses this), 1 = surfel debug
    camera.layers.enable(0);
    camera.layers.enable(1);

    // Content
    await buildScene(scene);

    // GUI params
    const params = {
      paused: false,

      // GBuffer
      gbufferScale: 0.5,

      // Pool
      capacity: 8192,

      // Brute-force coverage (the “no grid” part)
      maxCheck: 512,

      // Coverage kernel
      baseRadius: 0.10,
      radiusRefDist: 6.0,
      radiusOverscale: 1.25,
      normalSquish: 2.0,

      coverageThreshold: 0.12,
      keepAliveThreshold: 0.05,
      keepAliveCredit: 2,

      // Spawn probability
      spawnProb: 0.004,
      depthRef: 10.0,

      // Aging
      ttl: 300,
      ageStep: 1,
      forceKill: false,

      // Debug draw
      showSurfels: true,
      depthTest: true,
      visualRadiusScale: 0.9,
      showNormals: false,
      normalLen: 0.25,

      // Readback rate (Hz)
      debugHz: 10,

      // Buttons
      resetSurfels: () => {},
    };

    const gui = new GUI({ width: 340 });
    gui.title('Surfelization (No Grid)');

    // Pool + passes
    const pool = createSurfelPool();
    pool.ensureCapacity(params.capacity);

    const resetPass = createSurfelResetPass();
    const agePass = createSurfelAgePass();
    const findPass = createSurfelFindMissingBruteForcePass();
    const allocPass = createSurfelAllocatePass();

    // Apply initial reset
    resetPass.run(renderer, pool);

    // Debug meshes
    let debug = createSurfelDebugMeshes(scene, params.capacity);
    debug.mesh.material.depthTest = params.depthTest;

    params.resetSurfels = () => {
      resetPass.run(renderer, pool);
    };

    // GUI wiring
    {
      const f = gui.addFolder('GBuffer');
      f.add(params, 'gbufferScale', 0.15, 1.0, 0.01);
      f.open();
    }

    {
      const f = gui.addFolder('Pool');
      f.add(params, 'capacity', 512, 65536, 512).name('Max Surfels').onFinishChange((v) => {
        // resize pool + rebuild debug meshes + reset
        pool.ensureCapacity(v);
        scene.remove(debug.mesh);
        scene.remove(debug.lines);
        debug = createSurfelDebugMeshes(scene, v);
        debug.mesh.material.depthTest = params.depthTest;
        resetPass.run(renderer, pool);
      });
      f.add(params, 'resetSurfels').name('Reset');
      f.open();
    }

    {
      const f = gui.addFolder('Coverage (Brute Force)');
      f.add(params, 'maxCheck', 64, 4096, 64).name('Max surfels checked');
      f.add(params, 'baseRadius', 0.02, 0.5, 0.005);
      f.add(params, 'radiusRefDist', 0.5, 30.0, 0.1).name('Radius ref dist');
      f.add(params, 'radiusOverscale', 0.5, 3.0, 0.01).name('Radius overscale');
      f.add(params, 'normalSquish', 0.0, 6.0, 0.05).name('Normal squish');

      f.add(params, 'coverageThreshold', 0.0, 1.0, 0.005).name('Spawn if < coverage');
      f.add(params, 'keepAliveThreshold', 0.0, 1.0, 0.005).name('Touch if > weight');
      f.add(params, 'keepAliveCredit', 0, 10, 1).name('Touch credit');
      f.open();
    }

    {
      const f = gui.addFolder('Spawn');
      f.add(params, 'spawnProb', 0.0, 0.05, 0.0001).name('Spawn prob');
      f.add(params, 'depthRef', 1.0, 50.0, 0.25).name('Depth ref');
      f.open();
    }

    {
      const f = gui.addFolder('Aging');
      f.add(params, 'ttl', 10, 2000, 1).name('TTL');
      f.add(params, 'ageStep', 0, 5, 1).name('Age step');
      f.add(params, 'forceKill').name('Force kill (debug)');
      f.open();
    }

    {
      const f = gui.addFolder('Debug Draw');
      f.add(params, 'showSurfels');
      f.add(params, 'depthTest').onChange((v) => {
        debug.mesh.material.depthTest = v;
      });
      f.add(params, 'visualRadiusScale', 0.05, 3.0, 0.01);
      f.add(params, 'showNormals');
      f.add(params, 'normalLen', 0.01, 1.0, 0.01);
      f.add(params, 'debugHz', 1, 60, 1).name('Readback Hz');
      f.open();
    }

    gui.add(params, 'paused');

    // GBuffer
    let gbuffer = createGBuffer(renderer, params.gbufferScale);

    // Readback scheduling
    let lastReadbackMs = 0;
    let readbackInFlight = false;

    let lastAliveEstimate = 0;
    let lastTileCount = 0;

    function applyPassParams() {
      agePass.setParams({ ttl: params.ttl, ageStep: params.ageStep, forceKill: params.forceKill });

      findPass.setParams({
        ttl: params.ttl,
        maxCheck: params.maxCheck,
        baseRadius: params.baseRadius,
        radiusRefDist: params.radiusRefDist,
        radiusOverscale: params.radiusOverscale,
        normalSquish: params.normalSquish,
        coverageThreshold: params.coverageThreshold,
        keepAliveThreshold: params.keepAliveThreshold,
        keepAliveCredit: params.keepAliveCredit,
        spawnProb: params.spawnProb,
        depthRef: params.depthRef
      });
    }

    function resizeAll() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      gbuffer.resize(params.gbufferScale);
      // find/alloc will auto-rebuild when tileCount changes
    }

    window.addEventListener('resize', resizeAll);

    // ============================================================
    // 12) ANIMATION LOOP
    // ============================================================
    renderer.setAnimationLoop(() => {
      controls.update();

      // If gbufferScale changed in GUI, resize gbuffer target lazily
      // (cheap check; avoids rebuilding every frame)
      if (gbuffer.target) {
        const dpr = renderer.getPixelRatio ? renderer.getPixelRatio() : window.devicePixelRatio;
        const wantW = Math.max(1, Math.floor(window.innerWidth  * dpr * params.gbufferScale));
        const wantH = Math.max(1, Math.floor(window.innerHeight * dpr * params.gbufferScale));
        if (gbuffer.target.width !== wantW || gbuffer.target.height !== wantH) {
          gbuffer.resize(params.gbufferScale);
        }
      }

      applyPassParams();

      if (!params.paused) {
        // --- 1) GBUFFER PASS (layer 0 only) ---
        const prevTarget = renderer.getRenderTarget();
        renderer.setMRT(gbuffer.sceneMRT);
        renderer.setRenderTarget(gbuffer.target);

        // Render ONLY scene geometry
        camera.layers.set(0);
        renderer.render(scene, camera);

        renderer.setRenderTarget(prevTarget);
        renderer.setMRT(null);

        // --- 2) FIND MISSING (brute force) ---
        const { tileCount } = findPass.run(renderer, camera, gbuffer, pool);
        lastTileCount = tileCount;

        // --- 3) AGE / RECYCLE ---
        agePass.run(renderer, pool);

        // --- 4) ALLOCATE ---
        allocPass.run(renderer, pool, findPass, tileCount);

        // restore camera layers for display
        camera.layers.enable(1);
      }

      // --- 5) DISPLAY ---
      // Render scene geometry + surfels debug layer
      camera.layers.set(0);
      renderer.render(scene, camera);

      if (params.showSurfels) {
        camera.layers.set(1);
        renderer.render(scene, camera);
      }

      // --- 6) CPU readback for debug meshes (throttled) ---
      const now = performance.now();
      const intervalMs = 1000 / Math.max(1, params.debugHz);

      if (!readbackInFlight && (now - lastReadbackMs) >= intervalMs) {
        readbackInFlight = true;
        lastReadbackMs = now;

        pool.readbackAsync(renderer).then((arr) => {
          if (arr) {
            const visualRadius = params.baseRadius * params.visualRadiusScale;
            lastAliveEstimate = debug.updateFromReadback(
              arr,
              params.ttl,
              visualRadius,
              params.showNormals,
              params.normalLen
            );
          }
        }).finally(() => {
          readbackInFlight = false;
        });
      }

      hud.textContent =
`WebGPU Surfelization (no grid)
gbuffer: ${gbuffer.target.width}x${gbuffer.target.height}  (scale ${params.gbufferScale.toFixed(2)})
tiles:   ${lastTileCount}
alive≈   ${lastAliveEstimate} / ${params.capacity}
maxCheck ${params.maxCheck}
radius   ${params.baseRadius.toFixed(3)}  overscale ${params.radiusOverscale.toFixed(2)}
coverageThreshold ${params.coverageThreshold.toFixed(3)}
spawnProb ${params.spawnProb.toFixed(4)}  depthRef ${params.depthRef.toFixed(1)}
ttl ${params.ttl}  ageStep ${params.ageStep}
`;
    });
  </script>
</body>
</html>
